<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <link href="/theme/css/skeleton.css" rel="stylesheet">
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Basiliscos's blog</title>
        <meta content="Ivan Baidakou (aka basiliscos)" name="author">
        <meta content="Statocles 0.095" name="generator">
        <link href="/blog/index.atom" rel="alternate" type="application/atom+xml">
        <link href="/blog/index.rss" rel="alternate" type="application/rss+xml">
        
    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/">Basiliscos&#39;s blog</a>
                    <ul>
                        <li>
                            <a href="/">Blog</a>
                        </li>
                    </ul>
                    
                </div>
            </nav>
            
        </header>
        <div class="main container">
            <div class="row">
                <div class="nine columns">
                    <main>
                        

<article>
    <header>
        <h1><a href="/blog/2019/10/05/request-response-message-exchange-pattern/">Request Response Message Exchange Pattern</a></h1>

        <aside>
            <time datetime="2019-10-05">
                Posted on 2019-10-05
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
        </p>

    </header>

    <h1>Introduction</h1>

<p>The plan is to examine request/response pattern in &quot;abstract&quot; actor framework,
and find why it is not so trivial to implement as it might appear at the first. 
Later, we&#39;ll see how various C++ actor frameworks (CAF, sobjectizer, rotor) 
support the pattern.</p>

<p>The Request Response Message Exchange Pattern sounds quite simple: a <code>client</code> 
asks a <code>server</code> to proccess a <code>request</code> and return <code>response</code> to the client 
once it is done. </p>

<h1>Synchronous analogy</h1>

<p>This is completely artificial analogy, however it seem useful for further 
explanations.</p>

<p>It can be said, that in synchronous request-response can be simply presented as
just a regular function call, where <em>request</em> is input parameter to a function,
and the <em>response</em> is the return type, i.e. </p>

<pre><code>struct request_t { ... };
struct response_t { ... };

response_t function(const request_t&amp;) {  ... }
</code></pre>

<p>The &quot;server&quot; here is the <code>function</code> inself, and the &quot;client&quot; is the call-side side. </p>

<p>The semantic of this function says that the function <strong>always</strong> successfully
processes a request and return a result.</p>

<p>Probably, the most modern way to express that a function might fail is to 
wrap the response into monad-like wrapper,
like <a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a>, 
<a href="https://github.com/TartanLlama/expected">std::expected</a>, 
<a href="https://www.boost.org/doc/libs/1_70_0/libs/outcome/doc/html/index.html">boost::outcome</a>
etc. </p>

<p>Probably, the mostly used way to let the caller know that request processing 
failed is to throw an <em>exception</em>. However, it is not expressible in the modern C++,
so it should be mentioned somewhere in documentation or just assumed; in other
words, from the function signature <code>response_t function(const request_t&amp;)</code> never 
knows whether it always successfully processes request or sometimes it might
fail and thrown an exception. </p>

<h1>Problems of naive approach in actor framework</h1>

<p>Let&#39;s realize the simple request-response approach within the imaginary actor
framework: the <code>on_request</code> method of server-actor is called with the request
payload, and it returns the <code>response_t</code></p>

<pre><code>response_t server_t::on_request(request_t &amp;)
</code></pre>

<p>The naive implementation of request-response approach follows the
same pattern as in synchronous analogy, when it &quot;forgets&quot; to express that 
the request processing might fail. The actor framework responsibility is 
to wrap payload (<code>response_t</code>, <code>request_t</code>) into messages (<code>message&lt;request_t&gt;</code>) 
and deliver them as <em>messages</em> to related actors (client-actor, server-actor).
Later the payload will be unpacked.</p>

<p>The corresponding receiver interface of the client-actor will be like:</p>

<pre><code>void client_t::on_response(response_t&amp;)
</code></pre>

<p>While it looks OK, how will the client-actor be able to distinguish responses
from different requests? </p>

<p>The first solution would be to use some conventions on the request/response 
protocol, i.e. inject some synthetic <code>request_id</code> into <code>request_t</code> and 
somewhere into <code>response_t</code>, generate and set  it on request-side (client-actor) 
and presume that the server-actor will set it back together with the response.
There is a variation of the solution, when the <code>request_t</code> is completely 
embedded into <code>response_t</code>.</p>

<p>While this will definitely work as it will be shown below with <code>sobjectizer</code>
framework, this also means that <strong>there is no help from a actor framework</strong>
and the burden of the implementation lies completely on a developer. </p>

<p>The second solution is to let it be managed somehow by an actor framework:
let is suspend client-actor execution until the response will be received. 
The &quot;suspending&quot; in the context means that all messages for the client-actor
will be queued until the response will be received. </p>

<p>This will work as soon as everything goes fine. However, as soon as something
goes wrong (i.e. server-actor cannot process the request), the whole client-actor
will stuck: It will not able to process <em>any</em> message, because it infinitely
waits the particular one (the response).</p>

<p>In terms of actor-design the client-actor becomes <strong>non-reactive</strong> at the moment 
when it stops processing messages, which was a &quot;feature&quot; of the imaginary 
naive actor framework to &quot;wait&quot; the <code>response</code>. </p>

<p>You might guess, the per-request timeout timer, can resolve the problem. Yes, 
indeed, however how in the interface</p>

<pre><code>void client_t::on_response(response_t&amp;)
</code></pre>

<p>it is possible to tell client-actor about timeout trigger? I don&#39;t see an 
acceptable way to do that. It is paradoxical situation, that a failure
can be detected, but there is no way to react on it. </p>

<p>Anyway, even if there would be a way to notify client-actor about failure, 
it still does not completely solves the non-reactivity problem: an actor
becomes reactive only after timeout trigger, and until that it is still 
&quot;suspended&quot; waiting <code>response_t</code> or timeout trigger. </p>

<p>The root of the problem caused by &quot;forgetfulness&quot; of the server-actor
interface to specify, that it might fail. It&#39;s time to review our interfaces, 
then.</p>

<h1>No framework support for req/res pattern</h1>

<p>Let&#39;s summarize the necessary pieces, which are required to implement 
request/response pattern in actor-like manner. </p>

<p>First, the server-actor might fail in processing the request, and it 
need to tell the framework and client-actor about the failure.</p>

<p>Second, the response should enriched to contain the original <code>request_id</code>
to make it possible for client-actor to map the response to the request.
(In other sources it might be named <code>correlation_id</code>, which serves the
same purpose).</p>

<p>Third, the original request from the client-actor should also contain 
the <code>request_id</code>.</p>

<p>Forth, as the original response payload might be missing at all, it 
should be wrapped monad-like container (<code>std::optional</code>, <code>std::unique_ptr</code>
etc.)</p>

<p>So, our basic structures should look like:</p>

<pre><code>struct request_t { ... };
struct response_t { ... };
using request_id_t = std::uint32; /* as as example */

struct wrapped_request_t {
    request_id_t request_id;
    request_t req;
};

enum class request_error_t { SUCCESS, TIMEOUT, FAIL_REASON_1_1, ... };

struct wrapped_response_t {
    request_error_t request_error;
    request_id_t request_id;
    std::optional&lt;response_t&gt; res;  /* may be it&#39;ll contain the payload */
};
</code></pre>

<p>And the corresponding actor interfaces will be:</p>

<pre><code>wrapped_response_t server_t::on_request(wrapped_request_t&amp; ) { ... }

void client_t::on_response(wrapped_response_t&amp; ) { ... }
</code></pre>

<p>The <code>FAIL_REASON_1_1</code> and other error codes are desirable, if the server 
wants <strong>fail early</strong> and notify client about that. Otherwise, if server cannot 
process request, it silently ignores the request; however client will be notified
only via timeout and it can only guess, what exactly was wrong. In other words,
it is not good practice in general <em>ignore</em> wrong requests; react on them is
much better.</p>

<p>So, sending an request from client to server should be like:</p>

<pre><code>struct client_t {
    ...
    request_id_t last_request_id = 1;
};

void client_t::some_method() {
    auto req_id = ++last_request_id;
    auto request = request_t{ ... };
    framework.send(server_address, wrapped_request_t{ req_id, std::move(request) } );
}
</code></pre>

<p>However, the story does not end here, as the timeout-timer part is missing (i.e. 
for the case, when server-actor does not answer at all). The needed pieces are:
1) per request timeout timer; 2) when the response arrives in time, the timer
should be cancelled; 3) otherwise, the message with empty payload and timeout-fail
reason should be delivered;  4) if the response still arrives after timeout trigger,
it should be silently  discarded. There is a sense to have this things in dedicated methods. </p>

<pre><code>/* whatever that is able to identify particular timer instance */
using timer_id_t = ...; 

struct client_t {
    using timer_map_t = std::unordered_map&lt;timer_id_t, request_id_t&gt;;
    /* reverse mapping */
    using request_map_t = std::unordered_map&lt;request_id_t, timer_id_t&gt;; 
    ...
    request_id_t last_request_id = 1;
    timer_map_t timer_map;
    request_map_t request_map;
};

void client_t::some_method() {
    auto req_id = ++last_request_id;
    auto request = request_t{ ... };
    framework.send(server_address, wrapped_request_t{ req_id, std::move(request) } );
    /* start timer */
    auto timer_id = timers_framework.start_time(timeout);
    timer_map.emplace(timer_id, req_id);
    request_map.emplace(req_id, timer_id);
}

void client_t::on_timer_trigger(timer_id_t timer_id) {
    auto request_id = timer_map[timer_id];
    this-&gt;on_response(wrapped_response_t{ request_error_t::TIMEOUT,  request_id });
    timer_map.erase(timer_id);
    request_map.erase(request_id);
}

void client_t::on_response_guard(wrapped_response_t&amp; r) {
    if (request_map.count(r.request_id) == 0) {
        /* no timer, means timer already triggered and timeout-response was
        delivered, just discard the response */
        return;
    }
    auto timer_id = request_map[r.request_id];
    timers_framework.cancel(timer_id);
    this-&gt;on_response(r); /* actually deliver the response */
    timer_map.erase(timer_id);
    request_map.erase(request_id);
}
</code></pre>

<p>Now, the example is complete. It should be able to handle request-responses
in a robust way. However, there is no actual request processing code, and
a lot of auxiliary code to make it responsible and robust. </p>

<p>The worse thing, if that the boilerplate code have to be repeated for 
every request-response pair type. It is discouraging and error-prone way
of development; an developer might end up frustrated with actor-design
at all. </p>

<h1>req/res approach with sobjectizer</h1>

<p>The <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> actor framework
at the moment has version <code>5.6</code> and does not help in request-response pattern
usage. So, basically, it is like the request-response sample above without
framework support, with sobjectizer&#39;s specifics, of course.</p>

<p>In the example below the &quot;probabilistic pong&quot; (<code>server</code> role) is used: i.e. randomly
it successfully answers to ping-requests, and sometimes it just ignores the
requests. The <code>pinger</code> (<code>client</code> role) should be able to detect the both cases.</p>

<pre><code>#include &lt;so_5/all.hpp&gt;
#include &lt;optional&gt;
#include &lt;random&gt;
#include &lt;unordered_map&gt;

using request_id_t = std::uint32_t;
using namespace std::literals;

struct ping {};

struct pong {};

struct timeout_signal {
    request_id_t request_id;
};

enum class request_error_t { SUCCESS, TIMEOUT };

struct wrapped_ping {
    request_id_t request_id;
    ping payload;
};

struct wrapped_pong {
    request_id_t request_id;
    request_error_t error_code;
    std::optional&lt;pong&gt; payload;
};

class pinger final : public so_5::agent_t {
    using timer_t = std::unique_ptr&lt;so_5::timer_id_t&gt;;
    using request_map_t = std::unordered_map&lt;request_id_t, timer_t&gt;;

    so_5::mbox_t ponger_;
    request_map_t request_map;
    request_id_t last_request = 0;

    void on_pong(mhood_t&lt;wrapped_pong&gt; cmd) {
        auto &amp;timer = request_map.at(cmd-&gt;request_id);
        timer-&gt;release();
        request_map.erase(cmd-&gt;request_id);
        on_pong_delivery(*cmd);
    }

    void on_pong_delivery(const wrapped_pong &amp;cmd) {
        bool success = cmd.error_code == request_error_t::SUCCESS;
        auto request_id = cmd.request_id;
        std::cout &lt;&lt; &quot;pinger::on_pong &quot; &lt;&lt; request_id &lt;&lt; &quot;, success: &quot; &lt;&lt; success &lt;&lt; &quot;\n&quot;;
        so_deregister_agent_coop_normally();
    }

    void on_timeout(mhood_t&lt;timeout_signal&gt; msg) {
        std::cout &lt;&lt; &quot;pinger::on_timeout\n&quot;;
        auto request_id = msg-&gt;request_id;
        request_map.erase(request_id);
        wrapped_pong cmd{request_id, request_error_t::TIMEOUT};
        on_pong_delivery(cmd);
    }

  public:
    pinger(context_t ctx) : so_5::agent_t{std::move(ctx)} {}

    void set_ponger(const so_5::mbox_t mbox) { ponger_ = mbox; }

    void so_define_agent() override { so_subscribe_self().event(&amp;pinger::on_pong).event(&amp;pinger::on_timeout); }

    void so_evt_start() override {
        auto request_id = ++last_request;
        so_5::send&lt;wrapped_ping&gt;(ponger_, request_id);
        auto timer = so_5::send_periodic&lt;timeout_signal&gt;(*this, so_direct_mbox(), 200ms,
                                                         std::chrono::milliseconds::zero(), request_id);
        auto timer_ptr = std::make_unique&lt;so_5::timer_id_t&gt;(std::move(timer));
        request_map.emplace(request_id, std::move(timer_ptr));
    }
};

class ponger final : public so_5::agent_t {
    const so_5::mbox_t pinger_;
    std::random_device rd;
    std::mt19937 gen;
    std::uniform_real_distribution&lt;&gt; distr;

  public:
    ponger(context_t ctx, so_5::mbox_t pinger) : so_5::agent_t{std::move(ctx)}, pinger_{std::move(pinger)}, gen(rd()) {}

    void so_define_agent() override {
        so_subscribe_self().event([this](mhood_t&lt;wrapped_ping&gt; msg) {
            auto dice_roll = distr(gen);
            std::cout &lt;&lt; &quot;ponger::on_ping &quot; &lt;&lt; msg-&gt;request_id &lt;&lt; &quot;, &quot; &lt;&lt; dice_roll &lt;&lt; &quot;\n&quot;;
            if (dice_roll &gt; 0.5) {
                std::cout &lt;&lt; &quot;ponger::on_ping (sending pong back)&quot; &lt;&lt; std::endl;
                so_5::send&lt;wrapped_pong&gt;(pinger_, msg-&gt;request_id, request_error_t::SUCCESS, pong{});
            }
        });
    }
};

int main() {
    so_5::launch([](so_5::environment_t &amp;env) {
        env.introduce_coop([](so_5::coop_t &amp;coop) {
            auto pinger_actor = coop.make_agent&lt;pinger&gt;();
            auto ponger_actor = coop.make_agent&lt;ponger&gt;(pinger_actor-&gt;so_direct_mbox());

            pinger_actor-&gt;set_ponger(ponger_actor-&gt;so_direct_mbox());
        });
    });

    return 0;
}
</code></pre>

<p>Output sample:</p>

<pre><code>ponger::on_ping 1, 0.475312
pinger::on_timeout
pinger::on_pong 1, success: 0
</code></pre>

<p>Other output sample:</p>

<pre><code>ponger::on_ping 1, 0.815891
ponger::on_ping (sending pong back)
pinger::on_pong 1, success: 1
</code></pre>

<p>It should be noted, that request/response pattern <em>was</em> supported in sobjectizer 
<a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%20In-depth%20-%20Synchronous%20Interaction/">before</a> 
version <code>5.6</code>, however it was dropped (well, moved to 
<a href="https://sourceforge.net/p/sobjectizer/wiki/About%20so5extra/]">sobjectizer-extra</a>, which has
different licensing terms). The request/response was easy as the following like:</p>

<pre><code>auto r = so_5::request_value&lt;Result,Request&gt;(mbox, timeout, params);
</code></pre>

<p>It is convenient; nevertheless, from the explanation sample &quot;How does it work?&quot;, the following 
sample is available:</p>

<pre><code>// Waiting and handling the result.
auto wait_result__ = f__.wait_for(timeout);
if(std::future_status::ready != wait_result__)
   throw exception_t(...);
auto r = f__.get();
</code></pre>

<p>it suffers the same <strong>non-reactivity taint</strong> as described above, i.e. lack of possibility to
answer other messages, while waiting a response. Hence, you can see &quot;Deadlocks&quot; section
in the documentation, and the developers responsibility to handle the situation. </p>

<h1>req/res approach with CAF</h1>

<p>The <a href="http://actor-framework.org/">C++ actor framework</a> (aka CAF), does support request/response
approach. </p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;string&gt;

#include &quot;caf/all.hpp&quot;
#include &quot;caf/optional.hpp&quot;
#include &quot;caf/sec.hpp&quot;

using std::endl;
using std::string;
using namespace std::literals;

using namespace caf;

using ping_atom = atom_constant&lt;atom(&quot;ping&quot;)&gt;;
using pong_atom = atom_constant&lt;atom(&quot;pong&quot;)&gt;;

void ping(event_based_actor *self, actor pong_actor) {
  aout(self) &lt;&lt; &quot;ping&quot; &lt;&lt; endl;

  self-&gt;request(pong_actor, 1s, ping_atom::value)
      .then([=](pong_atom ok) { aout(self) &lt;&lt; &quot;pong received&quot; &lt;&lt; endl; },
            [=](error err) {
              aout(self) &lt;&lt; &quot;pong was NOT received (timed out?), error code = &quot;
                         &lt;&lt; err.code() &lt;&lt; endl;
            });
}

behavior pong(event_based_actor *self) {
  using generator_t = std::shared_ptr&lt;std::mt19937&gt;;
  using distrbution_t = std::shared_ptr&lt;std::uniform_real_distribution&lt;double&gt;&gt;;

  std::random_device rd;
  auto gen = std::make_shared&lt;typename generator_t::element_type&gt;(rd());
  auto distr = std::make_shared&lt;typename distrbution_t::element_type&gt;();
  return {[=](ping_atom) {
    auto dice = (*distr)(*gen);
    aout(self) &lt;&lt; &quot;pong, dice = &quot; &lt;&lt; dice &lt;&lt; endl;
    if (dice &gt; 0.5) {
      return optional&lt;pong_atom&gt;(pong_atom::value);
    }
    return optional&lt;pong_atom&gt;();
  }};
}

void caf_main(actor_system &amp;system) {
  auto pong_actor = system.spawn(pong);
  auto ping_actor = system.spawn(ping, pong_actor);
}

CAF_MAIN()
</code></pre>

<p>Output sample:</p>

<pre><code>ping
pong, dice = 0.571207
pong received
</code></pre>

<p>Another output sample:</p>

<pre><code>ping
pong, dice = 0.270214
pong was NOT received (timed out?), error code = 2
</code></pre>

<p>The call <code>client_actor-&gt;request(server_actor, timeout, args..)</code> returns an intermediate
future-like object, where <code>then</code> method can be invoked with forwarded one-shot 
actor behaviour. And, yes, there is <code>await</code> method too with non-reactive behaviour, 
where you can shoot easily yourself with deadlock. So, according to the 
<a href="https://actor-framework.readthedocs.io/en/latest/MessagePassing.html#sending-requests-and-handling-responses">documentation</a>
<code>then</code> method is what we need, as it &quot;multiplexes the one-shot handler with the 
regular actor behaviour and handles requests as they arrive&quot;. </p>

<h1>req/res approach with rotor</h1>

<p>The <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> does support request/response
approach since <code>v0.04</code></p>

<pre><code>#include &lt;rotor/ev.hpp&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;

namespace payload {
struct pong_t {};
struct ping_t {
    using response_t = pong_t;
};
} // namespace payload

namespace message {
using ping_t = rotor::request_traits_t&lt;payload::ping_t&gt;::request::message_t;
using pong_t = rotor::request_traits_t&lt;payload::ping_t&gt;::response::message_t;
} // namespace message

struct pinger_t : public rotor::actor_base_t {

    using rotor::actor_base_t::actor_base_t;

    void set_ponger_addr(const rotor::address_ptr_t &amp;addr) { ponger_addr = addr; }

    void on_initialize(rotor::message::init_request_t &amp;msg) noexcept override {
        rotor::actor_base_t::on_initialize(msg);
        subscribe(&amp;pinger_t::on_pong);
    }

    void on_start(rotor::message_t&lt;rotor::payload::start_actor_t&gt; &amp;) noexcept override {
        request&lt;payload::ping_t&gt;(ponger_addr).send(rotor::pt::seconds(1));
    }

    void on_pong(message::pong_t &amp;msg) noexcept {
        auto &amp;ec = msg.payload.ec;
        if (!msg.payload.ec) {
            std::cout &lt;&lt; &quot;pong received\n&quot;;
        } else {
            std::cout &lt;&lt; &quot;pong was NOT received: &quot; &lt;&lt; ec.message() &lt;&lt; &quot;\n&quot;;
        }
        supervisor.do_shutdown();
    }

    rotor::address_ptr_t ponger_addr;
};

struct ponger_t : public rotor::actor_base_t {
    using generator_t = std::mt19937;
    using distrbution_t = std::uniform_real_distribution&lt;double&gt;;

    std::random_device rd;
    generator_t gen;
    distrbution_t dist;

    ponger_t(rotor::supervisor_t &amp;sup) : rotor::actor_base_t{sup}, gen(rd()) {}

    void on_initialize(rotor::message::init_request_t &amp;msg) noexcept override {
        rotor::actor_base_t::on_initialize(msg);
        subscribe(&amp;ponger_t::on_ping);
    }

    void on_ping(message::ping_t &amp;req) noexcept {
        auto dice = dist(gen);
        std::cout &lt;&lt; &quot;pong, dice = &quot; &lt;&lt; dice &lt;&lt; std::endl;
        if (dice &gt; 0.5) {
            reply_to(req);
        }
    }
};

int main() {
    try {
        auto *loop = ev_loop_new(0);
        auto system_context = rotor::ev::system_context_ev_t::ptr_t{new rotor::ev::system_context_ev_t()};
        auto timeout = boost::posix_time::milliseconds{10};
        auto conf = rotor::ev::supervisor_config_ev_t{
            timeout, loop, true, /* let supervisor takes ownership on the loop */
        };
        auto sup = system_context-&gt;create_supervisor&lt;rotor::ev::supervisor_ev_t&gt;(conf);

        auto pinger = sup-&gt;create_actor&lt;pinger_t&gt;(timeout);
        auto ponger = sup-&gt;create_actor&lt;ponger_t&gt;(timeout);
        pinger-&gt;set_ponger_addr(ponger-&gt;get_address());

        sup-&gt;start();
        ev_run(loop);
    } catch (const std::exception &amp;ex) {
        std::cout &lt;&lt; &quot;exception : &quot; &lt;&lt; ex.what();
    }

    std::cout &lt;&lt; &quot;exiting...\n&quot;;
    return 0;
}
</code></pre>

<p>Output sample:</p>

<pre><code>pong, dice = 0.90477
pong received
</code></pre>

<p>Another output sample:</p>

<pre><code>pong, dice = 0.24427
pong was NOT received: request timeout
</code></pre>

<p>Comparing to <a href="http://actor-framework.org/">CAF</a>, <code>rotor</code>&#39;s version is more 
verbose in the terms of LOC (lines of code). Partly this is caused by omitted 
<code>main</code> in <code>CAF</code>, while in <code>rotor</code> the main cannot be shortened because
it is assumed to work with different loop backends as well as in cooperation
with them and other non-actor loop components; partly because of in <code>CAF</code> 
the message is hidden from user, while in <code>rotor</code> is is exposed outside
due to performance reasons (i.e. allow the payload to be smart-pointer
to have zero-copy); and finally because of <code>CAFs</code> intensive usage of 
lambdas, which leads to more compact code.</p>

<p>However, it is still what it needed: reactive reactive request-response.</p>

<h1>Request/Response composability</h1>

<p>On the top of <code>request-response</code> pattern, the <strong>ask pattern</strong> can be developed.
In short, an client-actor makes several of requests, and then, depending on the
results it makes an appropriate action. See 
<a href="https://doc.akka.io/docs/akka/current/actors.html#ask-send-and-receive-future">akka</a>
docs as an example, </p>

<p>However, the <strong>ask pattern</strong> it is a little bit more general: it should be 
possible to access to the initial context (message) as well as to all responses
(some of which might fail). </p>

<p>The <code>sobjectizer</code> does not offer support request-response patters, so it is out of
comparison. The <code>sobjectizer-extra</code> offers <code>std::future</code> based solution,
however, as we seen, it not reactive (<code>while(!fututure.is_ready()){ ... }</code>)
and as the <code>std::futures</code> are not compose-able, the <strong>ask pattern</strong> cannot
be implemented. </p>

<p>As we&#39;ve seen with <code>CAF</code> lambda approach, there are 2 lambdas <em>per request</em> 
(one is for fail response and another is for success response); each one 
captures outer request context and has access to its own response. Nonetheless,
none of the lambdas has access to the contexts of the other requests; in 
other words the common context (which can include the original message)
should be <em>shared</em> between them, and the code compactness seems to lost.</p>

<p>Here is an example how to compose two ping-pong requests, where any of them
might fail.</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;string&gt;

#include &quot;caf/all.hpp&quot;
#include &quot;caf/optional.hpp&quot;
#include &quot;caf/sec.hpp&quot;

using std::endl;
using std::string;
using namespace std::literals;

using namespace caf;

using ping_atom = atom_constant&lt;atom(&quot;ping&quot;)&gt;;
using pong_atom = atom_constant&lt;atom(&quot;pong&quot;)&gt;;

struct shared_context_t {
  std::size_t pings_left;
  std::size_t pings_success = 0;
  std::size_t pings_error = 0;

  shared_context_t(std::size_t pings_left_) : pings_left{pings_left_} {}

  void output_results() {
    if (pings_left == 0) {
      // unsafe, aout should be used, but how to capture it?
      std::cout &lt;&lt; &quot;success: &quot; &lt;&lt; pings_success &lt;&lt; &quot;, errors: &quot; &lt;&lt; pings_error
                &lt;&lt; &quot;\n&quot;;
    }
  }
  void record_success() {
    ++pings_success;
    --pings_left;
    output_results();
  }
  void record_fail() {
    ++pings_error;
    --pings_left;
    output_results();
  }
};

void ping(event_based_actor *self, actor pong_actor1, actor pong_actor2) {
  aout(self) &lt;&lt; &quot;ping&quot; &lt;&lt; endl;

  auto context = std::make_shared&lt;shared_context_t&gt;(2);
  self-&gt;request(pong_actor1, 1s, ping_atom::value)
      .then([=](pong_atom ok) { context-&gt;record_success(); },
            [=](error err) { context-&gt;record_fail(); });
  self-&gt;request(pong_actor2, 1s, ping_atom::value)
      .then([=](pong_atom ok) { context-&gt;record_success(); },
            [=](error err) { context-&gt;record_fail(); });
}

behavior pong(event_based_actor *self) {
  using generator_t = std::shared_ptr&lt;std::mt19937&gt;;
  using distrbution_t = std::shared_ptr&lt;std::uniform_real_distribution&lt;double&gt;&gt;;

  std::random_device rd;
  auto gen = std::make_shared&lt;typename generator_t::element_type&gt;(rd());
  auto distr = std::make_shared&lt;typename distrbution_t::element_type&gt;();
  return {[=](ping_atom) {
    auto dice = (*distr)(*gen);
    aout(self) &lt;&lt; &quot;pong, dice = &quot; &lt;&lt; dice &lt;&lt; endl;
    if (dice &gt; 0.5) {
      return optional&lt;pong_atom&gt;(pong_atom::value);
    }
    return optional&lt;pong_atom&gt;();
  }};
}

void caf_main(actor_system &amp;system) {
  auto pong_actor1 = system.spawn(pong);
  auto pong_actor2 = system.spawn(pong);
  auto ping_actor = system.spawn(ping, pong_actor1, pong_actor2);
}

CAF_MAIN()
</code></pre>

<p>Output sample:</p>

<pre><code>ping
pong, dice = 0.818207
pong, dice = 0.140753
success: 1, errors: 1
</code></pre>

<p>Another output sample:</p>

<pre><code>ping
pong, dice = 0.832334
pong, dice = 0.744168
success: 2, errors: 0
</code></pre>

<p>I&#39;m not <code>CAF</code>s expert, but it seems that in shared context it needs to 
be captured the original behaviour to access <code>aout</code>, and there is need
to have two methods per each request type (or single composed one 
with takes composite monad-like result).</p>

<p>Let&#39;s see how it works with <code>rotor</code>, however actors&#39; addressing should be
explained first. <code>Akka</code> and <code>CAF</code> actor frameworks use the <code>ActorRef</code> 
notion to (globally) identify an actor. It seems that there is one-to-one
matching between <code>ActorRef</code> and the actor. In <code>rotor</code> address is completely
decoupled from actor, and it can process messages on any address it is 
subscribed to. There is &quot;main&quot; (or default) actors address which is used
for main <code>rotor</code> mechanics, still it can be subscribed to any address 
and process messages on it.</p>

<p>That technique is shown below, when an <strong>ephemeral address</strong> is created
and an unique association between that address and context is created.
Here is a full code:</p>

<pre><code>#include &lt;rotor/ev.hpp&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;unordered_map&gt;

namespace payload {
struct pong_t {};
struct ping_t {
    using response_t = pong_t;
};
} // namespace payload

namespace message {
using ping_t = rotor::request_traits_t&lt;payload::ping_t&gt;::request::message_t;
using pong_t = rotor::request_traits_t&lt;payload::ping_t&gt;::response::message_t;
} // namespace message

struct shared_context_t {
    std::size_t pings_left;
    std::size_t pings_success = 0;
    std::size_t pings_error = 0;
};

struct pinger_t : public rotor::actor_base_t {
    using map_t = std::unordered_map&lt;rotor::address_ptr_t, shared_context_t&gt;;

    using rotor::actor_base_t::actor_base_t;

    void set_ponger_addr1(const rotor::address_ptr_t &amp;addr) { ponger_addr1 = addr; }
    void set_ponger_addr2(const rotor::address_ptr_t &amp;addr) { ponger_addr2 = addr; }

    void on_start(rotor::message_t&lt;rotor::payload::start_actor_t&gt; &amp;) noexcept override {
        reply_addr = create_address();
        subscribe(&amp;pinger_t::on_pong, reply_addr);
        request_via&lt;payload::ping_t&gt;(ponger_addr1, reply_addr).send(rotor::pt::seconds(1));
        request_via&lt;payload::ping_t&gt;(ponger_addr2, reply_addr).send(rotor::pt::seconds(1));
        request_map.emplace(reply_addr, shared_context_t{2});
    }

    void on_pong(message::pong_t &amp;msg) noexcept {
        auto &amp;ctx = request_map[msg.address];
        --ctx.pings_left;
        auto &amp;ec = msg.payload.ec;
        if (ec) {
            ++ctx.pings_error;
        } else {
            ++ctx.pings_success;
        }
        if (!ctx.pings_left) {
            std::cout &lt;&lt; &quot;success: &quot; &lt;&lt; ctx.pings_success &lt;&lt; &quot;, errors: &quot; &lt;&lt; ctx.pings_error &lt;&lt; &quot;\n&quot;;
            // optional cleanup
            unsubscribe(&amp;pinger_t::on_pong, reply_addr);
            request_map.erase(msg.address);
            supervisor.do_shutdown();
        }
    }

    map_t request_map;
    rotor::address_ptr_t ponger_addr1;
    rotor::address_ptr_t ponger_addr2;
    rotor::address_ptr_t reply_addr;
};

struct ponger_t : public rotor::actor_base_t {
    using generator_t = std::mt19937;
    using distrbution_t = std::uniform_real_distribution&lt;double&gt;;

    std::random_device rd;
    generator_t gen;
    distrbution_t dist;

    ponger_t(rotor::supervisor_t &amp;sup) : rotor::actor_base_t{sup}, gen(rd()) {}

    void on_initialize(rotor::message::init_request_t &amp;msg) noexcept override {
        rotor::actor_base_t::on_initialize(msg);
        subscribe(&amp;ponger_t::on_ping);
    }

    void on_ping(message::ping_t &amp;req) noexcept {
        auto dice = dist(gen);
        std::cout &lt;&lt; &quot;pong, dice = &quot; &lt;&lt; dice &lt;&lt; std::endl;
        if (dice &gt; 0.5) {
            reply_to(req);
        }
    }
};

int main() {
    try {
        auto *loop = ev_loop_new(0);
        auto system_context = rotor::ev::system_context_ev_t::ptr_t{new rotor::ev::system_context_ev_t()};
        auto timeout = boost::posix_time::milliseconds{10};
        auto conf = rotor::ev::supervisor_config_ev_t{
            timeout, loop, true, /* let supervisor takes ownership on the loop */
        };
        auto sup = system_context-&gt;create_supervisor&lt;rotor::ev::supervisor_ev_t&gt;(conf);

        auto pinger = sup-&gt;create_actor&lt;pinger_t&gt;(timeout);
        auto ponger1 = sup-&gt;create_actor&lt;ponger_t&gt;(timeout);
        auto ponger2 = sup-&gt;create_actor&lt;ponger_t&gt;(timeout);
        pinger-&gt;set_ponger_addr1(ponger1-&gt;get_address());
        pinger-&gt;set_ponger_addr2(ponger2-&gt;get_address());

        sup-&gt;start();
        ev_run(loop);
    } catch (const std::exception &amp;ex) {
        std::cout &lt;&lt; &quot;exception : &quot; &lt;&lt; ex.what();
    }

    std::cout &lt;&lt; &quot;exiting...\n&quot;;
    return 0;
}
</code></pre>

<p>Output sample:</p>

<pre><code>pong, dice = 0.472509
pong, dice = 0.305997
success: 0, errors: 2
</code></pre>

<p>Another output sample:</p>

<pre><code>pong, dice = 0.103796
pong, dice = 0.8862
success: 1, errors: 1
</code></pre>

<p>Rotor has special support of requests to be replied to custom addresses 
(i.e. <code>request_via</code> method). The main difference with the <code>CAF</code> that instead 
of multiple lambdas with additional methods (<code>record_success</code> and <code>record_fail</code>)
and &quot;gather-them-all&quot; method (<code>output_results</code>), with <code>rotor</code> there is
just single gather-them-all method (<code>on_pong</code>), which actually has exactly
the same signature when as the previous example with <code>rotor</code>.</p>

<h1>Conclusion</h1>

<p>When you start thinking about possible failures the initially request 
response schema abruptly becomes non-trivial. Timeout and other errors
should be handled and without framework support the code quite quickly 
becomes cumbersome.</p>

<p>There is still additional requirements, that the provided by a framework
support of request/response pattern did not come of cost of loosing 
actor&#39;s <em>reactivity</em>; for simplicity, you may treat it as 
dead-lock avoidance. Another nice-to-have feature would be composability
of the requests. </p>

<p>At the moment <code>sobjectizer</code> does not provides request/response pattern, 
however in the past it did, however it was <em>non-reactive</em>. </p>

<p>Both <code>CAF</code> and <code>rotor</code> do provide request/response pattern keeping 
still actors <em>reactive</em>. <code>CAF</code> has more compact code; the <code>rotor&#39;s</code> 
code is more verbose. It seems that in <code>CAF</code> you should roll
you own composability of requests, i.e. develop context class 
and make it shared between different requests handlers. In <code>rotor</code>
the composability of requests seems more natural via creating
ephemeral reply addresses, which can associate the linked group 
of requests in single place. </p>

<h1>Update</h1>

<p>The <code>sobjectizer</code> author replied with separate
<a href="https://eao197.blogspot.com/2019/10/progc-follow-up-for-basiliscoss-article.html">article</a>.
, which I recommend to read.</p>

<p>So, it should be updated, that <a href="https://github.com/Stiffstream/so5extra">sobjetizer-extra</a>
provides support for request-response pattern, but only via a bit
different name (<code>async_op</code>, in the case). It is completely 
asynchronous and free of dead-locks, i.e. <strong>reactive</strong>.</p>

<p>It is also
<a href="https://github.com/eao197/so5-request-reply-example/blob/master/dev/sample_composability_2/main.cpp">composable</a>,
with the approximately same lines of code as <code>rotor</code> example. 
The composability is done via lambdas (as in <code>CAF</code>), but 
the responses are redirected to different <code>mboxes</code> (as the
ephemeral addresses in <code>rotor</code>).</p>

<p>So, it is possible to get the same result with all considered 
frameworks.</p>



</article>
<article>
    <header>
        <h1><a href="/blog/2019/08/19/cpp-supervisors/">Trees of Supervisors in C++ (caf, sobjectizer, rotor)</a></h1>

        <aside>
            <time datetime="2019-08-19">
                Posted on 2019-08-19
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
        </p>

    </header>

    <h1>The notion of supervisor &amp; trees of supervisors</h1>

<p>Erlang is famous for its <a href="http://erlang.org/doc/design_principles/sup_princ.html">erlang-supervisor</a> approach, i.e. an actor which is
responsible managing it&#39;s child actors lifetime (start, restart, shutdown).</p>

<p>In regular C++ code an error (exception) propagates towards the caller-side.
In actor-based approach error is supervised by an actor owner (supervisor) and
it&#39;s up to supervisor to decide how to react, e.g. restart actor but if it
crashed no more than 3 times per minute. The caller-side is decoupled from
this details at all.</p>

<p>In the case of child crash supervisor might decide either to restart it,
or, if the local situation is considered too bad, then shutdown itself (and all it&#39;s
children) and <em>delegate</em> the problem upwards, i.e. to is&#39;t own supervisor.
The parent supervisor might, again, decide either restart or delegate the
problem upwards again.</p>

<p>That form of delegating problem upto root supervisor naturally form tree
of responsibilities, or, if you like, tree of supervision. This allows
to an application slowly degrade and still be available (provide service)
when non-fatal errors occur.</p>

<h1>C++ supervising specifics</h1>

<p>Erlang supervisors tolerate even programmer errors; this is known as <a href="http://wiki.c2.com/?LetItCrash">let-it-crash</a>
principle, as a supervisor will just respawn crashed actor.</p>

<p>In C++ we cannot tolerate developer mistakes as in Erlang: there is no
reasonable reaction in general to leaked memory or <code>std::abort()</code> call, right?
Instead, in C++ world we assume that an actor is able to detect that it
is in invalid state, and just terminate, possibly notifying it&#39;s exit
reason upwards. In the upper layer the actor exit will be observed,
and a decision will be made how to handle with the situation.</p>

<h1>Supervisor-like capabilities of caf &amp; sobjectizer</h1>

<h2>caf (c++ actor framework)</h2>

<p>There is no explicit supervisor role in <a href="https://actor-framework.org/">caf</a>. However, according to
documentation <a href="https://actor-framework.readthedocs.io/en/latest/MessagePassing.html#down-handler">caf-monitor</a>, it is possible to subscribe to special system
<em>down message</em> and provide appropriate reaction. This can be done in recursive
manner, i.e. tree of responsibilities <em>can</em> be build.</p>

<p>However, if I read documentation correctly, any actor can monitor
any other actor death. The responsibility of reaction is somewhat blurred
from the API perspective. Let&#39;s name the approach <em>supervising-via-monitoring</em>.</p>

<p>As the actors are spawned (and owned) by <code>system</code>, the application at the
runtime does not creates an hierarchy, i.e. it is flat:</p>

<p><img alt="caf.png" src="/blog/2019/08/19/cpp-supervisors/caf.png"></p>

<p>There is actors groupping capabilities in <a href="https://actor-framework.org/">caf</a>, which allows to multicast 
messages to all actors inside the group, e.g. shutdown messsage.</p>

<h2>sobjectizer</h2>

<p>In <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> actors (agents, in the sobjectizer&#39;s terminology) are spawned
by <code>cooperation</code>; the cooperation itself is created by <code>environment</code> (the
similar role to <code>system</code> in <a href="https://actor-framework.org/">caf</a>). <code>cooperations</code> can create child <code>cooperations</code>,
thus making a hierarchy.</p>

<p>However, it should be noted, that <code>cooperation</code> in <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> <em>in not an actor</em>;
it is the type provided by <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> and there is no possibility to roll 
your own implementation.</p>

<p>The <code>cooperation</code> in <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> is some kind of supervisable group of actors,
as it requires that all actors to be started and successfully registered; if
any of them fails, coorepation will shutdown and unregister all (already registered)
actors.</p>

<p>Actors <em>are managed</em> by <code>cooperations</code>; how actors can get back the information
from <code>cooperations</code>? The <code>notificator</code> object should be created by <code>cooperation</code>
with the messages destination <code>mbox</code>; then the notificator object should be added
into the cooperation. Notificators are two kinds: <code>reg</code> and <code>dereg</code>, i.e. they
observe actors startup or shutdown events. Lastly, actor should subscribe
to the appropriate event on the message box. However,this is not an individual
actor shutdown event, it is <em>whole cooperation</em> shutdown event (<code>registration</code>
or <code>deregistration</code>).</p>

<p>Now follows my own vision how to get <em>fine-gained</em> supervising.</p>

<p>Thus, there is no <em>direct</em> actor shutdown observation; only indirect (i.e. 
via cooperation death notification). If there is need to observe individual 
actor shutdown, it should be the only actor on a <code>cooperation</code>, and the 
cooperation should be monitored; in the case of actor crash, it the new 
cooperation should be spawned, and the new actor should be spawned on it, 
and the monitoring subscription routine above should be repeated.</p>

<p>This can be visualized as the following:</p>

<p><img alt="sobjectizer.png" src="/blog/2019/08/19/cpp-supervisors/sobjectizer.png"></p>

<p>However, this looks a little bit overcomplicated. Indeed, <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>
way of supervising is <em>coarse-grained</em> supervising: not individual actors
should be supervised, but group of related actors (<code>cooperation</code>).</p>

<p><img alt="sobjectizer-coarse.png" src="/blog/2019/08/19/cpp-supervisors/sobjectizer-coarse.png"></p>

<p>For more details, please refer <a href="https://bitbucket.org/sobjectizerteam/sobjectizer/wiki/so-5.6-docs/tutorials/underhood.md">sobjectizer-underhood</a>.</p>

<h1>Supervising in Rotor</h1>

<p>In <a href="https://github.com/basiliscos/cpp-rotor/">rotor</a> we&#39;d like to achieve <em>fine-gained</em> Erlang-like supervising:</p>

<p><img alt="rotor.png" src="/blog/2019/08/19/cpp-supervisors/rotor.png"></p>

<p>Please note the absence of dotted lines, as they coincide with the solid
lines, because the <em>ownership</em> of an actor is the same of <em>supervising</em> it.
An supervisor in <a href="https://github.com/basiliscos/cpp-rotor/">rotor</a> is also an actor. The supervising hierarchy is
naturally formed (unlike in <a href="https://actor-framework.org/">caf</a>), and still there are no doubling
of the hierarchy as in <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>, where framework supplied managing
units (<code>cooperations</code>) are intermixed with user supplied actors.</p>

<p>However, parent-child relation between supervisors upto <code>v0.02</code> version
was available only for <a href="https://www.boost.org:/doc/libs/release/libs/asio/" title="Boost Asio">boost-asio</a> based supervisors... because each
supervisor incorporated own <code>strand</code>, which was generated by root
<code>io_context</code>. That way it was a mixture of execution controller
and supervising; so the real picture was like:</p>

<p><img alt="rotor-v0.02.png" src="/blog/2019/08/19/cpp-supervisors/rotor-v0.02.png"></p>

<p>Nonetheless, it imposed the sequential execution context (<code>strand</code>) for every
supervisor, while it not necessary was needed. Also, the supervising hierarchy
was not available for other event-loops, because <code>strand</code> seems the <a href="https://www.boost.org:/doc/libs/release/libs/asio/" title="Boost Asio">boost-asio</a>
unique feature.</p>

<p>To solve the situation, the <code>locality</code> notion was introduced. Under the hood,
it is plain <code>const void*</code> marker. By default, locality just a pointer to
root supervisor, if two supervisors has the same locality, they are executed
in the same (thread-safe) context. This makes it possible to have supervising
trees in all supported event loops in rotor.</p>

<p>How about <a href="https://www.boost.org:/doc/libs/release/libs/asio/" title="Boost Asio">boost-asio</a>? <code>locality</code> here become a pointer to <code>strand</code>, making
it possible to introduce executing context (implies supervising) on demand,
i.e. something like this:</p>

<p><img alt="rotor-v0.03.png" src="/blog/2019/08/19/cpp-supervisors/rotor-v0.03.png"></p>

<p>Here <code>supervisor_root</code>, <code>supervisor_1</code>, <code>supervisor_2</code> are executed on
the context on one <code>strand</code>, while <code>supervisor_2</code> has it&#39;s own <code>strand</code>.</p>

<p>This is available in <a href="https://github.com/basiliscos/cpp-rotor/">rotor</a> <code>v0.03</code>. (This led to API breaking changes,
as now boost::asio supervisor takes <code>strand</code> shared pointer in config).</p>

<h2>Rotor v0.03 messaging internals</h2>

<p>Messaging in rotor done without private actor&#39;s message boxes unlike
<a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> and <a href="https://actor-framework.org/">caf</a>. Every <code>address</code> (message delivery endpoint) is generated
by a <code>supervisor</code> a reference to the supervisor is embedded into the <code>address</code>.
So, during messages processing phase by each supervisor, it compared the reference
in message destination <code>address</code> with the self (<code>this</code>), and if the match occurs
the message was routed locally; otherwise the message was delivered for other
<code>supervisor</code> for further (local) routing.</p>

<p>Since <a href="https://github.com/basiliscos/cpp-rotor/">rotor</a> <code>v0.03</code> <code>address</code> object also embeds <code>locality</code> (<code>const void*</code>). If
it matches to the <code>locality</code> of the supervisor, then the destination supervisor is
taken from the <code>address</code> and the message is <em>immediately locally routed</em> in the
context of the destination supervisor.</p>

<p>To make it possible, all supervisors with the same locality have to share the
same queue of messages. The obvious way to achieve that is that child-supervisors
with the same locality use root supervisor&#39;s messages queue.</p>

<p>In other words, a message is sent to locality, where all it&#39;s supervisors are
<em>peers entry points</em>.</p>



</article>

<ul class="pager">
    <li class="prev">
            <button disabled>
                ← Older
            </button>
    </li>
    <li class="next">
            <button disabled>
                Newer →
            </button>
    </li>
</ul>




                    </main>
                </div>

                <div class="three columns sidebar">
                    
                        <nav id="tags">
        <h1>Tags</h1>
        <ul class="list-inline">
        </ul>
    </nav>

                            <h1>Feeds</h1>
        <ul class="list-inline">
            <li>
                <a href="/blog/index.atom" rel="alternate" type="application/atom+xml">
                    Atom
                </a>
            </li>
            <li>
                <a href="/blog/index.rss" rel="alternate" type="application/rss+xml">
                    RSS
                </a>
            </li>
        </ul>

                </div>
            </div>
        </div>
        <footer>
            
            <div class="container tagline">
                <a href="http://preaction.me/statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>


    </body>
</html>
