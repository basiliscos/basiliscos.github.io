<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <link href="/theme/css/skeleton.css" rel="stylesheet">
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Basiliscos's blog</title>
        <meta content="Ivan Baidakou (aka basiliscos)" name="author">
        <meta content="Statocles 0.097" name="generator">
        <link href="/blog/index.atom" rel="alternate" type="application/atom+xml">
        <link href="/blog/index.rss" rel="alternate" type="application/rss+xml">
        
    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/">Basiliscos&#39;s blog</a>
                    <ul>
                        <li>
                            <a href="/">Blog</a>
                        </li>
                    </ul>
                    
                </div>
            </nav>
            
        </header>
        <div class="main container">
            <div class="row">
                <div class="nine columns">
                    <main>
                        

<article>
    <header>
        <h1><a href="/blog/2022/09/07/rotor-light-announcement/">rotor-light announcement</a></h1>

        <aside>
            <time datetime="2022-09-07">
                Posted on 2022-09-07
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
        </p>

    </header>

    <p>I was asked by a few friends of mine to develop something like 
<a href="https://github.com/basiliscos/cpp-rotor/">rotor</a> but to be
usable on embedded, with the restrictions for embedded
platform like no dynamic allocations, no RTTI etc. Please,
meet the <a href="https://notabug.org/basiliscos/cpp-rotor-light">rotor-light</a>,
which is capable to run even on 8-bit AVR microcontroller
(Arduino Uno R3)!</p>



</article>
<article>
    <header>
        <h1><a href="/blog/2022/04/09/rotor-v022-and-thread-unsafety/">rotor v0.22 and thread unsafety</a></h1>

        <aside>
            <time datetime="2022-04-09">
                Posted on 2022-04-09
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
        </p>

    </header>

    <p>There is not so well explained <code>BUILD_THREAD_UNSAFE</code>
<a href="https://github.com/basiliscos/cpp-rotor/">rotor</a> build option. Technically
it means, that <a href="https://www.boost.org/doc/libs/1_78_0/libs/smart_ptr/doc/html/smart_ptr.html#intrusive_ptr">boost&#39;s intrusive ptr</a>
is used in thread-unsafe manner, i.e. the underlying reference counter
is not atomic. Accordingly, all objects (in our case messages and actors from
<code>rotor</code>) cannot be accessed from different threads concurrently.</p>

<p>It should be explicitly mentioned, that rotor&#39;s cross-thread messaging facility
also cannot be used, otherwise there is notorious UB (undefined behavior).</p>

<p>Practically that usually means, that you are building single-threaded
application, most likely a service with asio/ev backend.</p>

<p>Why you might need that feature? <strong>Performance</strong> is the answer, i.e.
when you need rotor supervising/messaging facilities in single-threaded app.
According to my measurements, with the thread-unsafety you&#39;ll get <strong>~30.8</strong>
millions of messages per second instead of <strong>~23.5</strong> with the feauture disabled,
i.e. ~30% of performance boost for free.</p>

<p>The question arises, then, how to stop that single threaded application?
With the thread safety it can be done via launching additional thread, which
monitors some <em>atomic flag</em>, and, once it detects that it is set, it sends
shutdown signal to the root supervisor. The <em>atomic flag</em> is set externally,
i.e. in signal handler (NB: you cannot send shutdown message within
signal handler as all memory allocations are prohibited).</p>

<pre><code>...
struct sigaction action;
memset(&amp;action, 0, sizeof(action));
action.sa_handler = [](int) { shutdown_flag = true; };
auto r = sigaction(SIGINT, &amp;action, nullptr);
...
auto console_thread = std::thread([&amp;] {
    while (!shutdown_flag) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    supervisor-&gt;shutdown();
});

supervisor-&gt;start();
io_context.run();
console_thread.join();
</code></pre>

<p>However, this is no longer possible with thread-unsafety option. What
can be done instead, is periodical flag checking from the rotor
thread itself, i.e. using timers from root supervisor. I found that
I use that feature frequently, so I decided to include it in 
<a href="https://github.com/basiliscos/cpp-rotor/">rotor</a>: in supervisor
builder there is needed to specify reference to the shutdown_flag
and the frequency of checking it, i.e.:</p>

<pre><code>rth::system_context_thread_t ctx;
auto timeout = r::pt::milliseconds{100};
auto sup = ctx.create_supervisor&lt;rth::supervisor_thread_t&gt;()
               .timeout(timeout)
               .shutdown_flag(shutdown_flag, timeout / 2)
               .finish();
</code></pre>

<p>(You still need to have to set it externally, like in the example
above with <code>sigaction</code> call). When it detects the flag is set to
<code>true</code> it shuts self down.</p>

<p>The full example of usage can be seen at
<a href="https://github.com/basiliscos/cpp-rotor/blob/master/examples/thread/sha512.cpp">examples/thread/sha512.cpp</a></p>

<p><code>BUILD_THREAD_UNSAFE</code> is turned off by default. You should explicitly turn
it on if you are knowning what you are doing.</p>



</article>
<article>
    <header>
        <h1><a href="/blog/2022/02/20/supervising-in-c-how-to-make-your-programs-reliable/">Supervising in C++: how to make your programs reliable</a></h1>

        <aside>
            <time datetime="2022-02-20">
                Posted on 2022-02-20
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
        </p>

    </header>

    <h2>Supervising in real world</h2>

<p>When some extraordinary situation is met it can be handled at the problem level
or its handling can be delegated to some upper level. Usually, when it
is really extraordinary, it is delegated or ... it becomes exception handling.</p>

<p>Imagine, you are in a supermarket, and suddenly smoke and fire appear and for some
reason there is no fire alert signals. What would you do? You can try to
extinguish fire by yourself, or notify a supermarket employee about the problem and
let he handle the situation. It is likely an employee has codified instructions to
notify his direct manager or a fire service.</p>

<p>The key point here is that the extraordinary situation is not handled by you, but
by a person, who knows how to deal with it. Of course, you can try to handle it
by your own, but there might be consequences if you are not the person,
responsible for the situation.</p>

<h2>Supervising in backend and end-user services</h2>

<p>All non-trivial programs have bugs, however most of well-known cloud services are run
smoothly and we rarely notice them. This happens, because our programs are
externally supervised by devops programs like <code>systemd</code> or <code>runit</code>. Simplified, their
job can be described as following: if a program &quot;hangs&quot; kill it and start again,
if it exited, just restart it. In any case it leads to program <em>restart</em>.</p>

<p>There is, probably, the hardware supervising team too, and conceptually its job is
similar: if a router or server rack does not operate properly, turn it off and then
turn it on, i.e. <em>restart</em>.</p>

<p>For the regular end user of desktop application the situation is similar: when a
program misbehaves, it is terminated by the user or its operating system, and then,
probably the program will be started again by the user.</p>

<p>Despite different domains, the universal pattern is the same: give the buggy
application another chance by restarting it.</p>

<h2>Why there is no supervising in common C/C++/C#/Java/Perl/... programs</h2>

<p>Did you frequently see a desktop program, which works with network, and, when you
suddenly plug off the network cable (or turn off wifi router), it continues to
operate with some disabled functions, and when you plug the cable back in, the
program becomes fully operational as if there was no emergency at all?</p>

<p>Did you frequently see a backend app, which can easily outlive the loss of
connection to a database or messages queue or other critical resource? My experience
tells me, that level of error handling is very rare, and usually is not even
discussed.</p>

<p>&quot;We are not in the military/healthcare/aerospace/nuclear domain&quot;. That is true, in
short. A little bit more verbose and technical answer is: handling all that
exceptional cases requires writing additional <strong>special code</strong>, which is extremely
difficult to test (manually or automatically), it will significantly increase code
development and maintenance costs without any significant benefits...</p>

<h2>Actors as a solution</h2>

<p><a href="https://en.wikipedia.org/wiki/Actor_model_theory">Actor</a> is an independent entity with
its own lifetime and state, all the interaction with an actor happens only via
messaging, including actor start and stop signal. Thus, if something bad happens,
e.g., actor enters error state, it shuts self down and sends appropriate
message to its supervisor actor.</p>

<p>Let&#39;s emphasize the point: all communications with an actor are performed via messaging,
and if something wrong occurs, there will be appropriate message too, i.e. messaging
is universal.</p>

<p>The normal flow looks like the following (consumer point of view): client-actor sends
a request message to service-actor, and when the request processing by the service-actor
is completed, the response message is sent back to the client. The supervisor of the
service-actor does not participate in the communications; the same as in real life.</p>

<p>The error flow looks like the following from consumer point of view: client-actor sends
a request message to service-actor, and it receives a response with error from
the service-actor or, if something really terrible has happend, request timeout triggers,
which is conceptually the same as receive message with error. The service-actor,
however, has a few possibilities: if there is a problem with request, it can just
reply with error code; if there is an unrecoverable problem during error processing,
it can reply back with error to the client-actor and shut self down, i.e. send <code>down</code>
message to its supervisor.</p>

<p>Thus, the error flow is &quot;doubled&quot;: (1) the client receives error and takes its own
decision what to do with error and (2) the supervisor decides how to deal with
an actor&#39;s shutdown. Supervisor&#39;s decision is usually either to restart the problematic
actor (which originally triggered the error), or, if (possibly a several) restarts
do not fix the problem (i.e. service-actor still shuts self down), <strong>escalate the
problem</strong>, which means, to shut the supervisor down, to shutdown all child actors,
and then send <code>down</code> message to the <em>upstream supervisor</em> for further making decisions.</p>

<p>This approach is very different from widely used <em>exception handling</em>, where there is
a context for handling immediate error (1), but there isn&#39;t a context for supervising (2).
This is not accidental, because <em>using the service</em> (client role) is different from
<em>owning the service</em> (supervising role).</p>

<p>A few questions might arise.</p>

<p><strong>How to cope with unexpected or fatal errors?</strong> In theory, it is possible not to
handle this errors manually (with code) at all, just specifying restart policy for
the chosen framework/platform should be enough. It will simply just keep trying with
restarts until some reasonable limit is reached, then escalate the problem, restarting
the hierarchy of actors an so on... until it is solved, that after all possible attempts
have been tried and further trying has no sense, and the problem should be escalated
<em>outside</em> of the program, e.g. to human or to operating system.</p>

<p><strong>OK, the service-actors are keeping restarting (supervisor side), does it affect
client side?</strong> If it is OK for a client side to receive timeout responses when
service-actors have already been down and have not been started yet, then the answer is &quot;<strong>no</strong>&quot;.
The technical explanation is, that the message destination endpoint is not
bind to the concrete actor: in <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>
any actor can subscribe to any address, in
<a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> any agent can subscribe
to any message box.</p>

<p><strong>Does supervising tolerates developer errors?</strong> It depends on chosen platform. For
the Erlang case, with its <a href="https://wiki.c2.com/?LetItCrash">let it crash</a> principle,
developer errors lead to an actor crash, and supervisor can make further decision.
For the C++ errors like use-after-free or null pointer dereference or memory leaks
cannot be &quot;catch&quot;, so they are not recoverable and program crash or memory abuse
should be supervised externally by operating system or launchers like <code>systemd</code>.</p>

<p><strong>Can you give more practical examples?</strong> Sure. Consider there is a backend
application, which has a fast distributed cache and slow network connection to
a database. Can the app continue to serve, if the connection is suddenly gone?
<em>May be</em>, if it is OK to serve read-only requests via cache, trying to reconnect
to DB &quot;in background&quot;; this might be better than just cold restarts of the
whole app via system manager. Even if it cant, the time to become operational for
the app is fasten than the cold restart, because there is no need of cache reloading.
Can the app continue to serve, if the connection to network cache is lost?
<em>Surely</em>, it can serve a bit slower is better and it is better than a cold restart.
If backend and cache connections handling does not cost a lot in terms
of development and maintenance, the approach is definitely worth.</p>

<h2>The price</h2>

<p>Supervising is not free of charge. If you chose <a href="https://www.erlang.org/">Erlang</a> as
a platform, you receive the maximum flexibility in supervising, including tolerance
up to let-it-crash and possibility to send messages transparently to actors located
on non-local machine. However, the price is quite high, as you have to use rather
specific erlang language, the platform itself is slow comparing to native binaries
you get when you use C++/Go etc., and, if you want to speed up hot code path via
writing native extensions, you immediately loose all the benefits of the platform.
Somewhat specific syntax can be mitigated by using <a href="https://elixir-lang.org/">Elixir</a>
language.</p>

<p>In any case the messaging have to be used for actor environment, and it is not as
fast as native methods call: the memory for a message have to be allocated, the
message fields have to be filled, the message has to be dispatched etc. In summary
a message delivery can be hundred or more times expensive than a native call.</p>

<p>Another indirect costs of using messaging are that a framework has to be used,
because sending messages and especially receiving them cannot be performed without a
context. For C++ it can be <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>,
<a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> or
<a href="https://actor-framework.org/">C++ actor framework</a>, while erlang it itself
a platform and a framework (OTP).</p>

<p><strong>So, what is the total cost ownership of supervising?</strong> In theory it is nearly
zero cost in terms of writing special code (it should be done for you), but
you will be bounded to the platform/framework and the usage of messaging also
has its own performance price.</p>

<h2>Technical details of supervising in C++</h2>

<p><a href="https://actor-framework.org/">C++ actor framework</a> (aka CAF) is considered the
most influenced by <a href="https://www.erlang.org/">Erlang</a>, however, the supervising
itself is missing in it. CAF is capable  to run a cluster of nodes, each one can run
arbitrary number of actors. The strong point of CAF is <em>transparent messaging</em>
(actor addressing), i.e. when a message can be sent from one actor to another,
independently from their locations, i.e. they can be located on different
machines, on the same machine, or in the same process.</p>

<p>The situation with supervising is slightly better with
<a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>, as it provides
entity named <code>cooperation</code>, which has elemental supervising capabilities,
such as synchronized actors startup (shutdown): either all actors, belonging
to the same <code>cooperation</code>, do all start or no actor starts; and, similar,
if an actor from <code>cooperation</code> stops, all actors on the same cooperation
stop. It should be noted, that <code>cooperation</code> class is completely belongs
to the <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> framework,
and it is not possible to override something in it or somehow customize.
It is possible to hook actor shutdown event, and send shutdown notification
message somewhere, but that&#39;s a bit wrong way of building
supervising as it requires to handle a lot of things in your actors, which
is violation of
<a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single Responsibility Principle</a>.
With <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> you can
construct hierarchical finite state machines, which are tightly integrated
with messaging, or you can use go-like channels for messaging. So,
it is still good framework if you need those features.</p>

<p>Supervising is one of the key features of <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>
since the beginning. There is the <code>supervisor_t</code> class, which manages
its child-actors; it is fully customizable, i.e. child-actor start
and stop events can be hooked etc. However, real erlang-like
<a href="https://www.erlang.org/doc/design_principles/sup_princ.html">supervising</a>
was not part of the microframework until <code>v0.20</code>. In short, since <code>v0.20</code>
it is possible to</p>

<p>1) declaratively specify failure escalation of each actor upon it&#39;s
construction:</p>

<pre><code>supervisor-&gt;create_actor&lt;actor_type&gt;()
    .timeout(timeout)
    .escalate_failure()        /* will shut down in error case */
    .finish();
</code></pre>

<p>2) declaratively respawn stopped actor, until some condition is
met, and, otherwise escalate failure</p>

<pre><code>namespace r = rotor;
auto actor_factory = [&amp;](r::supervisor_t &amp;supervisor, const r::address_ptr_t &amp;spawner) -&gt; r::actor_ptr_t {
    return sup
        .create_actor&lt;actor_type&gt;()
        .timeout(timeout)
        // other actor properties, probably taken from supervisor
        .spawner_address(spawner)
        .finish();
};

supervisor-&gt;spawn(actor_factory)
    .max_attempts(15)                               /* don&#39;t do that endlessly */
    .restart_period(boost::posix_time::seconds{10})
    .restart_policy(r::restart_policy_t::fail_only) /* respawn only on failure */
    .escalate_failure()                             /* we did our best, shutdown supervisor */
    .spawn();
</code></pre>

<p>The full example of the spawner pattern for ping-pong (where pinger-actor shuts self
down upon unsuccessful <code>pong</code> reply) can be seen
<a href="https://github.com/basiliscos/cpp-rotor/blob/master/examples/thread/ping-pong-spawner.cpp">here</a>.</p>

<h2>Conclusion</h2>

<p>If something went wrong in your program, give that piece of program another
chance, <strong>restart</strong> it. Maybe it was a temporal network issue, and it can disapper
with the next attempt; just wait a little bit and try again, but don&#39;t be too
assertive. One of the possible ways of organizing your program, into that
self-contained pieces, with own resources and lifetime, is to model them as
<a href="https://en.wikipedia.org/wiki/Actor_model_theory">actors</a>, which communicate
with each other via <strong>messaging</strong>. Shape the individual actors into manageable
hierarchies with <strong>supervisors</strong>, which provide fine-gained control of actors
at a low-level and at a high-level. Make your program reliable.</p>

<p><img alt="terminator.jpg" src="/blog/2022/02/20/supervising-in-c-how-to-make-your-programs-reliable/terminator.jpg"></p>



</article>
<article>
    <header>
        <h1><a href="/blog/2020/10/08/rotor-v0.09-release/">rotor v0.09 release</a></h1>

        <aside>
            <time datetime="2020-10-08">
                Posted on 2020-10-08
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
        </p>

    </header>

    <p>The original article was published at <a href="https://habr.com/">habr.com</a> in <a href="https://habr.com/ru/company/crazypanda/blog/522588/">English</a> and <a href="https://habr.com/ru/company/crazypanda/blog/522892/">Russian</a>. Due to outstanding changes I decided to write a decicated article explaining <code>rotor</code> and key points in a new release.</p>

<p><a href="https://github.com/basiliscos/cpp-rotor">rotor</a> is a <a href="https://basiliscos.github.io/cpp-rotor-docs/md__home_b_development_cpp_cpp-rotor_docs_Rationale.html">non-intrusive</a> event loop friendly C++ actor micro framework, similar to its elder brothers like <a href="https://actor-framework.org/">caf</a> and <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>. The new release came out under the flag of <strong>pluginization</strong>, which affects the entire lifetime of an actor.</p>

<h2>Actor Linking</h2>

<p>The actor system is all about interactions between actors, i.e. sending messages to each other (and producing side effects for the outer world or listening to messages it produces). However, to let a message be delivered to the final actor, the actor should <strong>be alive</strong> (1); in other words, if actor <code>A</code> is going to send message <code>M</code> to actor <code>B</code>, <code>A</code> should somehow be sure that actor <code>B</code> is online and will not go offline while <code>M</code> is routing.</p>

<p>Before <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> <code>v0.09</code>, that kind of warranty was only available due to child-parent relations, i.e. between supervisor and its child-actor. In this case, an actor was guaranteed that a message would be delivered to its supervisor because the supervisor <em>owned</em> the actor and said supervisor&#39;s lifetime covered the respective actor&#39;s lifetime. Now, with the release of <code>v0.09</code>, it is possible to link actor <code>A</code> with actor <code>B</code> that are not parent- or child-related to one another and to make sure that all messages will be delivered after successful linking .</p>

<p>So, linking actors is performed somewhat along these lines:</p>

<pre><code>namespace r = rotor;

void some_actor_t::on_start() noexcept override {
    request&lt;payload::link_request_t&gt;(b_address).send(timeout);
}

void some_actor_t::on_link_response(r::message::link_response_t &amp;response) noexcept {
    auto&amp; ec = message.payload.ec;
    if (!ec) {
        // successful linking
    }
}
</code></pre>

<p>However, code like this should not be used directly as is... because it is inconvenient. It becomes more obvious if you try linking actor <code>A</code> with 2 or more actors (<code>B1</code>, <code>B2</code>, etc.), since <code>some_actor_t</code> should keep an internal count of how many target actors are waiting for (successful) link responses. And here the pluginization system featured in the <code>v0.09</code> release comes to the rescue:</p>

<pre><code>namespace r = rotor;

void some_actor_t::configure(r::plugin::plugin_base_t &amp;plugin) noexcept override {
    plugin.with_casted&lt;r::plugin::link_client_plugin_t&gt;(
        [&amp;](auto &amp;p) {
            p.link(B1_address);
            p.link(B2_address);
        }
    );
}
</code></pre>

<p>Now, this is much more convenient, since <code>link_client_plugin_t</code> is included out of the box with the <code>rotor::actor_base_t</code>. Nevertheless, it&#39;s still not enough, because it does not answer a few important questions, such as: 1. When is actor linking performed (and a &quot;by-question&quot;: when is actor <strong>unlinking</strong> performed)? 2. What happens if the target actor (aka &quot;server&quot;) does not exist or rejects linking? 3. What happens if the target actor decides to self-shutdown when there are &quot;clients&quot; still linked to it?</p>

<p>To provide answers to these questions, the concept of actor lifetime should be revisited.</p>

<h2>Async Actor Initialization And Shutdown</h2>

<p>Represented in a simplified manner is, here is how an actor’s state usually changes: <code>new</code> (constructor) -&gt; <code>initializing</code> -&gt; <code>initialized</code> -&gt; <code>operational</code> -&gt; <code>shutting down</code> -&gt; <code>shut down</code></p>

<p>The main job is performed in the <code>operational</code> state, and it is up to the user to define what an actor is to do in its up-and-running mode.</p>

<p>In the <strong>I-phase</strong> (i.e. <code>initializing</code> -&gt; <code>initialized</code>), the actor should prepare itself for further functioning: locate and link with other actors, establish connection to the database, acquire whichever resources it needs to be operational. The key point of <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> is that I-phase is <strong>asynchronous</strong>, so an actor should notify its supervisor when it is ready (2).</p>

<p>The <strong>S-phase</strong> (i.e. <code>shutting down</code> -&gt; <code>shut down</code>) is complementary to the <strong>I-phase</strong>, i.e. the actor is being asked to shut down, and, when it is done, it should notify its supervisor.</p>

<p>While it sounds easy, the tricky bit lies in the <strong>composability</strong> of actors, when they form Erlang-like hierarchies of responsibilities (see my article on <a href="https://basiliscos.github.io/blog/2019/08/19/cpp-supervisors/">trees of Supervisors</a>). In other words, any actor can fail during its <code>I-phase</code> or <code>S-phase</code>, and that can lead to asynchronous collapse of the entire hierarchy, regardless of the failed actor&#39;s location within it. Essentially, the entire hierarchy of actors becomes <code>operational</code>, or, if something happens, the entire hierarchy becomes <code>shut down</code>.</p>

<p><a href="https://github.com/basiliscos/cpp-rotor">rotor</a> seems unique with its init/shutdown approach. There is nothing similar in <a href="https://actor-framework.org/">caf</a>;
in <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>, there is a <a href="https://sourceforge.net/p/sobjectizer/wiki/so5extra%201.0%20Shutdowner/">shutdown helper</a>, which
carries a function similar to the <code>S-phase</code> above; however, it is limited to one actor only and offers no <code>I-phase</code> because <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> has no concept of hierarchies (see <strong>update</strong> below).</p>

<p>While using <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>, it was discovered that the progress of the <code>I-phase</code> (<code>S-phase</code>) may potentially require <em>many</em> resources to be acquired (or released) asynchronously, which means that no single component, or actor, is able, by its own will, to answer the question of whether it has or has not completed the current phase. Instead, the answer comes as a result of collaborative efforts, handled in the right order. And this is where <strong>plugins</strong> come into play; they are like pieces, with each one responsible for a particular job of initialization/shutdown.</p>

<p>So, here are the promised answers related to <code>link_client_plugin_t</code>:</p>

<ul>
<li>Q: When is the actor linking or unlinking performed? A: When the actor state is <code>initializing</code> or <code>shutting down</code> respectively.</li>
<li>Q: What happens if the target actor (aka &quot;server&quot;) does not exist or rejects linking? A: Since this happens when the actor state is <code>initializing</code>, the plugin will detect the fail condition and will trigger client-actor shutdown. That may trigger a cascade effect, i.e. its supervisor will be triggered to shut down, too.</li>
<li>Q: What happens if the target actor decides to self-shutdown when there are &quot;clients&quot; still linked to it? A: The &quot;server-actor&quot; will ask its clients to unlink, and once all &quot;clients&quot; have confirmed unlinking, the &quot;server-actor&quot; will continue the shutdown procedure (3).</li>
</ul>

<h2>A Simplified Example</h2>

<p>Let&#39;s assume that there is a database driver with async-interface with one of the available event-loops for <code>rotor</code>, and there will be TCP-clients connecting to our service. The database will be served by <code>db_actor_t</code> and the service for serving clients will be named <code>acceptor_t</code>. The database actor is going to look like this:</p>

<pre><code>namespace r = rotor;

struct db_actor_t: r::actor_base_t {

    struct resource {
        static const constexpr r::plugin::resource_id_t db_connection = 0;
    }

    void configure(r::plugin::plugin_base_t &amp;plugin) noexcept override {
        plugin.with_casted&lt;r::plugin::registry_plugin_t&gt;([this](auto &amp;p) {
            p.register_name(&quot;service::database&quot;, this-&gt;get_address())
        });
        plugin.with_casted&lt;r::plugin::resources_plugin_t&gt;([this](auto &amp;) {
            resources-&gt;acquire(resource::db_connection);
            // initiate async connection to database
        });
    }

    void on_db_connection_success() {
        resources-&gt;release(resource::db_connection);
        ...
    }

    void on_db_disconnected() {
        resources-&gt;release(resource::db_connection);
    }

    void shutdown_start() noexcept override {
        r::actor_base_t::shutdown_start();
        resources-&gt;acquire(resource::db_connection);
        // initiate async disconnection from database, e.g. flush data
    }
};
</code></pre>

<p>The inner namespace <code>resource</code> is used to identify the database connection as a resource. It is good practice, better than hard-coding magic numbers like <code>0</code>. During the actor configuration stage (which is part of initialization), when <code>registry_plugin_t</code> is ready, it will asynchronously register the actor address under a symbolic name of <code>service::database</code> in the <code>registry</code> (will be shown further down below). Then, with the <code>resources_plugin_t</code>, it acquires the database connection resource, blocking any further initialization and launching connection to the database. When connection is established, the resource is released, and the <code>db_actor_t</code> becomes <code>operational</code>. The <code>S-phase</code> is symmetrical, i.e. it blocks shutdown until all data is flushed to DB and connection is closed; once this step is complete, the actor will continue its shutdown (4).</p>

<p>The client acceptor code should look like this:</p>

<pre><code>namespace r = rotor;
struct acceptor_actor_t: r::actor_base_t {
    r::address_ptr_t db_addr;

    void configure(r::plugin::plugin_base_t &amp;plugin) noexcept override {
        plugin.with_casted&lt;r::plugin::registry_plugin_t&gt;([](auto &amp;p) {
            p.discover_name(&quot;service::database&quot;, db_addr, true).link();
        });
    }

    void on_start() noexcept override {
        r::actor_base_t::on_start();
        // start accepting clients, e.g.
        // asio::ip::tcp::acceptor.async_accept(...);
    }

    void on_new_client(client_t&amp; client) {
        // send&lt;message::log_client_t&gt;(db_addr, client)
    }
};
</code></pre>

<p>The key point here is the <code>configure</code> method. When <code>registry_plugin_t</code> is ready, it is configured to discover the name <code>service::database</code> and, when found, store it in the <code>db_addr</code> field; it then links the actor to the <code>db_actor_t</code>. If <code>service::database</code> is not found, the acceptor shuts down (i.e. <code>on_start</code> is not invoked); if the linking is not confirmed, the acceptor shuts down, too. When everything is fine, the acceptor starts accepting new clients.</p>

<p>The operational part itself is missing for the sake of brevity because it hasn&#39;t changed in the new <code>rotor</code> version: there is a need to define payload and message (including request and response types), as well as define methods which will accept the messages and finally subscribe to them.</p>

<p>Let&#39;s bundle everything together in a <code>main.cpp</code>. Let&#39;s assume that the <code>boost::asio</code> event loop is used.</p>

<pre><code>namespace asio = boost::asio;
namespace r = rotor;

...
asio::io_context io_context;
auto system_context = rotor::asio::system_context_asio_t(io_context);
auto strand = std::make_shared&lt;asio::io_context::strand&gt;(io_context);
auto timeout = r::pt::milliseconds(100);
auto sup = system_context-&gt;create_supervisor&lt;r::asio::supervisor_asio_t&gt;()
               .timeout(timeout)
               .strand(strand)
               .create_registry()
               .finish();

sup-&gt;create_actor&lt;db_actor_t&gt;().timeout(timeout).finish();
sup-&gt;create_actor&lt;acceptor_actor_t&gt;().timeout(timeout).finish();

sup-&gt;start();
io_context.run();
</code></pre>

<p>The <code>builder</code> pattern is actively used in the <code>v0.09</code> <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>. Here, the root supervisor <code>sup</code> was created with 3 actors instantiated on it: the user defined <code>db_actor_t</code> and <code>acceptor_actor_t</code> and implicitly created a registry actor. As is typical for the actor system, all actors are decoupled from one another, only sharing message types (skipped here).</p>

<p>All actors are simply created here, and the supervisor does not know the relations between them because actors are loosely coupled and have become more autonomous since <code>v0.09</code>.</p>

<p>Runtime configuration can be completely different: actors can be created on different threads, different supervisors, and even using different event loops, but the actor implementation remains the same (5). In that case, there will be more than one root supervisor; however, to let them find each other, the <code>registry</code> actor address should be shared between them. This is also supported via the <code>get_registry_address()</code> method of <code>supervisor_t</code>.</p>

<h2>Summary</h2>

<p>The most important feature of <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> <code>v0.09</code> is the pluginization of its core. Among other <a href="https://basiliscos.github.io/cpp-rotor-docs/index.html">plugins</a>, the most important are: the <code>link_client_plugin_t</code> plugin, which maintains kind of a &quot;virtual connection&quot; between actors; the <code>registry_plugin_t</code>, which allows registering and discovering actor addresses by their symbolic names; and the <code>resources_plugin_t</code>, which suspends actor init/shutdown until external asynchronous events occur.</p>

<p>There are a few less prominent changes in the release, such as the new non-public properties <a href="https://basiliscos.github.io/blog/2020/07/23/permission-model/">access</a> and builder pattern for actor construction.</p>

<p>Any feedback on <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> is welcome!</p>

<p>PS. I&#39;d like to say thanks to Crazy Panda for supporting me in my actor model research.</p>

<h3>Notes</h3>

<p>(1) Currently, it will lead to segfault upon attempt to deliver a message to an actor whose supervisor is already destroyed.</p>

<p>(2) If it does not notify, init-request timeout will occur, and the actor will be asked by its supervisor to shut down, i.e. bypass the <code>operational</code> state.</p>

<p>(3) You might ask: what happens if a client-actor does not confirm unlinking on time? Well, this is somewhat of a violation of contract, and the <code>system_context_t::on_error(const std::error_code&amp;)</code> method will be invoked, which, by default, will print error to <code>std::cerr</code> and invoke <code>std::terminate()</code>. To avoid contract violation, shutdown timeouts should be tuned to allow client-actors to unlink on time.</p>

<p>(4) During shutdown, the <code>registry_plugin_t</code> will unregister all registered names in the <code>registry</code>.</p>

<p>(5) With the exception of when different event loops are used, when actors use the event loop API directly, they will, obviously, change following the event loop change, but that&#39;s beyond <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>.</p>

<h3>Update</h3>

<p>During discussings with <code>sobjectizer</code> author below, it was clarified <code>sobjectizer</code> <a href="https://github.com/Stiffstream/so5extra/wiki/so5extra-1.4-Shutdowner">shutdowner</a> and <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5.19%20Stop%20guards/">stop guard</a> offer &quot;long lasting&quot; shutdown actions, however it&#39;s main purpose to give some actors additional time for shutdown, even if on the <code>Environment</code> <code>stop</code> was invoked. The asynchronous shutdown (and initialization) similar to <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> <code>I-phase</code> and <code>S-phase</code> can be modeled via actor&#39;s states, if needed. This is, however, framework <strong>users</strong> responsibility, contrary to <code>rotor</code>, where it is <strong>the framework</strong> responsibility.</p>



</article>
<article>
    <header>
        <h1><a href="/blog/2020/07/23/permission-model/">C++ permission model</a></h1>

        <aside>
            <time datetime="2020-07-23">
                Posted on 2020-07-23
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
        </p>

    </header>

    <h1>Abstract</h1>

<p>The problems of <code>public</code>, <code>protected</code> and <code>private</code> access are considered.
The generic templated <code>access</code> approach  with the on-demand specialization
for a consumer is proposed; it&#39;s advantages and drawbacks are discussed.
The synthetic solution satisfactory enough is proposed in the conclusion.</p>

<h1>The problem</h1>

<p>Out of the box C++ offers &quot;classical&quot; class access model: <code>public</code> properties
(fields and methods) are accessible from anywhere, <code>protected</code> properties
are accessible to descendant classes only, and finally <code>private</code> properties
which permit access to class itself only.</p>

<p>Additionally it is possible to declare <code>friend</code> class (which might be templated)
to provide maximum access to all properties (i.e. the same as <code>private</code>). This
allows to access to the internals of a class to a <strong>related</strong> class.</p>

<p>For example, if there is an HTTP-library with <code>Request</code> and <code>Connection</code> classes
and <code>Request</code> class would like to access <code>Connection</code> internals, this can be done
as:</p>

<pre><code>class Request;  /* forward declare */

enum class Shutdown { read, write, both };
class Connection {
    public:
        virtual void handle() { ... }
    private:
        void shutdown(Shutdown how) { ...;  }
        int skt;
        friend class Request;
};

class Request {
    public:
        virtual void process() {
            ...;
            /* I know what I&#39;m doing */
            conn-&gt;shutdown(Shutdown::both);
        }
    protected:
      Connection* conn;
};
</code></pre>

<p>Now let&#39;s assume that there is an descendant</p>

<pre><code>class HttpRequest: public Request {
    public:
        virtual void process() override {
            conn-&gt;shutdown(Shutdown::both); // Oops!
        }
};
</code></pre>

<p>Alas, there is no way in C++ to access to <code>Connection::shutdown</code> from it.
To overcome this, with the current access model, there are the possibilities.
<em>First</em>, it is possible to declare <code>HttpRequest</code> as a friend in the <code>Connection</code>.
Whilst this will certainly work, the solution has strict limitation, that it
applicable only for single library (project) to code of which you have access.
Otherwise, <em>it does not scales at all</em>.</p>

<p>The <em>second</em> possibility if is to &quot;expose&quot; private connection from the <code>Request</code>
class to all it&#39;s descendants, like:</p>

<pre><code>class Request {
    protected:
        void connection_shutdown(Shutdown how) {  conn-&gt;shutdown(how); }
        int&amp; connection_socket() {  conn-&gt;skt; }
        const int&amp; connection_socket() const {  conn-&gt;skt; }
        Connection* conn;
};
</code></pre>

<p>This approach is better, because it scales to all descendant classes which can
be located in different libraries. However, the price is quite high as there
is need to provide access to all properties apriori even if some properties
will not be needed. The more serious drawback is that the approach is limited
to class inheritance; in other words, if there is need to access private
properties of <code>Connection</code> not from <code>Request</code>&#39;s descendants, e.g. for tests.</p>

<p>Somebody might become disappointed at all and try to make everything <strong>public by
default</strong>. This scales well and covers all abovedescribed issues though brings
a new ones: the boundary between stable <em>public</em> API interface and <em>private</em>
implementation details of a class is blurred and completion suggestions in
an IDE can be overloaded with too many variants. In other words the proposed
approach is <em>too permissive</em>.</p>

<p>Semantically identical would be to write simple <strong>accessors for all private
properties</strong>; it just brings an <em>illusion</em> of the interface/implementation
separation since a class author already exposed all class internals outside.</p>

<p>Let&#39;s summarize the requirements for the private properties (aka implementation
details):</p>

<ul>
<li><p>they should scale outside of a library</p></li>
<li><p>they should be accessible outside of class hierarchy</p></li>
<li><p>they should not &quot;pollute&quot; the class public API, i.e. somehow be not
available by default, still be accessible</p></li>
</ul>

<h1>The possible solutions</h1>

<p>It consists of two pieces, the first one is to declare possibility to access
the private fields of a class, e.g.:</p>

<pre><code>// my_library.h
namespace my::library {
    class Connection {
        public:
            virtual void handle() { ... }
            template&lt;typename T...&gt; auto&amp; access() noexcept;
        private:
            void shutdown(Shutdown how) { ...;  }
            int skt;
    };
}
</code></pre>

<p>The second piece is actually provide full access specialization in the
target place, e.g. :</p>

<pre><code>// my_app.cpp
namespace to {
    struct skt{}; // matches private field
}

namespace my::library {
    auto&amp; Connection::access&lt;to::skt&gt;() noexcept { return skt; }
}

// namespace does not matter
class HttpRequest: public Request {
    public:
        virtual void process() override {
            auto&amp; s = conn-&gt;access&lt;to::skt&gt;();  // voila!
            shutdown(s, SHUT_RDWR);
        }
};
</code></pre>

<p>In other words, in the source class the generic templated accessor
is defined, and in the place, where the access is needed, the specialization
is provided as the actual access to the required fields.</p>

<p>The solution meets all requirements, however it still has it&#39;s own drawbacks.
First, there is need of duplication of <code>const</code> and <code>non-const</code> access, i.e.</p>

<pre><code>class Connection {
    public:
        virtual void handle() { ... }
        template&lt;typename T...&gt; auto&amp; access() noexcept;
        template&lt;typename T...&gt; auto&amp; access() const noexcept;
};

...

namespace my::library {
    auto&amp; Connection::access&lt;to::skt&gt;() noexcept       { return skt; }
    auto&amp; Connection::access&lt;to::skt&gt;() const noexcept { return skt; }
}
</code></pre>

<p>Although, you don&#39;t have to provide <code>const</code> and <code>non-const</code> access if you need
only one.</p>

<p>The second drawback, that to let the approach work <em>for methods</em>, especially
those, which return type can&#39;t be <code>auto&amp;</code> (e.g. <code>void</code> or <code>int</code>). To overcome
it the <code>access</code> should be rewritten as:</p>

<pre><code>class Connection {
    public:
        template&lt;typename T, typename... Args&gt; T access(Args...);
}

namespace my::library {
    void Connection::access&lt;void, Shutdown&gt;(Shutdown how) {
        return shutdown(how);
    }
}

class HttpRequest: public Request {
    public:
        virtual void process() override {
            conn-&gt;access&lt;void, Shutdown&gt;(Shutdown::both);
        }
};
</code></pre>

<p>Another problem arises: if there are two or more private methods with identical
signatures (return and arguments types), the artificial tag should be introduced
again, i.e.</p>

<pre><code>class Connection {
    template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...);
};

namespace to {
    struct skt{};
    struct shutdown{};
}

namespace my::library {
    int&amp; Connection::access&lt;int&amp;, to::skt&gt;() { return skt; }
    void Connection::access&lt;void, to::shutdown, Shutdown&gt;(Shutdown how) {
        shutdown(how);
    }
}

...
conn-&gt;access&lt;void, to::shutdown&gt;(Shutdown::both); // voila!
</code></pre>

<p>The variadic <code>Args...</code> template parameter dos not force to duplicate the original
arguments; it can have even add unrelated types to &quot;inject&quot; new methods with additional
logic into the <code>Connection</code> class. For example:</p>

<pre><code>namespace to {
    struct fun{}
}

namespace my::library {
    void Connection::access&lt;void, to::fun&gt;() {
        Shutdown how = std::rand() &gt; 1000 ? Shutdown::read ? Shutdown::write;
        shutdown(how);
    }
}
</code></pre>

<p>It is known, that methods might have optional <code>noexcept</code> specification in addition
to <code>const</code>. So, for the sake of generality, all four access cases should be
provided, i.e.:</p>

<pre><code>class Connection {
public:
template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...);
template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...) const;
template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...) noexcept;
template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...) const noexcept;
};
</code></pre>

<p>Alas, it was not the last problem with the approach: there is a problem with inheritance,
e.g.:</p>

<pre><code>class Connection {
    template&lt;typename T&gt; auto&amp; access();
private:
    int skt;
};

enum class SslState { /* whatever */};

class SslConnection:public Connection {
public:
    template&lt;typename T&gt; auto&amp; access();
private:
    SslState state;
};

namespace to {
    struct skt{};
    struct state{};
}

namespace my::library {
    auto&amp; Connection::access&lt;to::skt&gt;() { return skt; }
    auto&amp; SslConnection::access&lt;to::state&gt;() { return state; }
}
</code></pre>

<p>However, as soon as try to access to parent property via child class, i.e.:</p>

<pre><code>SslConnection* conn = ...;
auto&amp; skt = conn-&gt;access&lt;to::skt&gt;(); // oops!
</code></pre>

<p>It cannot resolve access to socket via <code>SslConnection</code> because there is no
<code>to::skt</code> specialization for <code>SslConnection</code>; there is on in it&#39;s parent class,
but in accordance with C++ rules a compiler does not see it. The solution
is to cast to the base class:</p>

<pre><code>SslConnection* conn = ...;
auto&amp; skt = static_cast&lt;Connection*&gt;(conn)-&gt;access&lt;to::skt&gt;();
</code></pre>

<p>This becomes even more unhandy when an object is stored behind smart pointer.</p>

<p>Let&#39;s enumerate key points:</p>

<ul>
<li><p>accessors multiplication due to <code>const</code> and <code>noexcept</code> variants</p></li>
<li><p>not so handy access for private methods (too verbose due to multiple template
params), although &quot;injection&quot; of own accessor-methods seems an advantage</p></li>
<li><p>too clumpsy syntax to access private proreties in class hierarchy</p></li>
</ul>

<h1>Conclusion</h1>

<p>The proposed solution is far from perfect. I found the following golden ratio
for my projects on the implementation details access topic:</p>

<ul>
<li><p>if the property is stable enough or it is the part of class interface,
then public accessor should be written for it. It would be desirable for
read only access, i.e. the accessor should be just a getter. For example,
the <code>address</code> property in <code>actor_base</code> in
<a href="https://github.com/basiliscos/cpp-rotor/blob/master/include/rotor/actor_base.h">rotor</a>.</p></li>
<li><p>otherwise, if implementation details might be usable in descendants,
make them <code>private</code></p></li>
<li><p>provide generic templated accessor (<code>template&lt;typename T&gt; auto&amp; access()</code>)
but for properties only; no access to private methods, as I don&#39;t see possible
use cases now. This point might be different for different projects.</p></li>
</ul>

<p>The described approach is applied in to be released soon
<a href="https://github.com/basiliscos/cpp-rotor">rotor</a> <code>v0.09</code>.</p>



</article>

<ul class="pager">
    <li class="prev">
            <a class="button button-primary" href="/blog/page/2/" rel="prev">
                ← Older
            </a>
    </li>
    <li class="next">
            <button disabled>
                Newer →
            </button>
    </li>
</ul>




                    </main>
                </div>

                <div class="three columns sidebar">
                    
                        <nav id="tags">
        <h1>Tags</h1>
        <ul class="list-inline">
            <li><a href="/blog/tag/c/">c++</a></li>
            <li><a href="/blog/tag/rotor/">rotor</a></li>
        </ul>
    </nav>

                            <h1>Feeds</h1>
        <ul class="list-inline">
            <li>
                <a href="/blog/index.atom" rel="alternate" type="application/atom+xml">
                    Atom
                </a>
            </li>
            <li>
                <a href="/blog/index.rss" rel="alternate" type="application/rss+xml">
                    RSS
                </a>
            </li>
        </ul>

                </div>
            </div>
        </div>
        <footer>
            
            <div class="container tagline">
                <a href="http://preaction.me/statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>


    </body>
</html>
