<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <meta content="width=device-width, initial-scale=1" name="viewport">
        <link href="/theme/css/normalize.css" rel="stylesheet">
        <link href="/theme/css/skeleton.css" rel="stylesheet">
        <link href="/theme/css/statocles-default.css" rel="stylesheet">
        <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet">
        <title>Basiliscos's blog</title>
        <meta content="Ivan Baidakou (aka basiliscos)" name="author">
        <meta content="Statocles 0.097" name="generator">
        <link href="/blog/index.atom" rel="alternate" type="application/atom+xml">
        <link href="/blog/index.rss" rel="alternate" type="application/rss+xml">
        
    </head>
    <body>
        <header>
            <nav class="navbar">
                <div class="container">
                    <a class="brand" href="/">Basiliscos&#39;s blog</a>
                    <ul>
                        <li>
                            <a href="/">Blog</a>
                        </li>
                    </ul>
                    
                </div>
            </nav>
            
        </header>
        <div class="main container">
            <div class="row">
                <div class="nine columns">
                    <main>
                        

<article>
    <header>
        <h1><a href="/blog/2022/04/09/rotor-v022-and-thread-unsafety/">rotor v0.22 and thread unsafety</a></h1>

        <aside>
            <time datetime="2022-04-09">
                Posted on 2022-04-09
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
        </p>

    </header>

    <p>There is not so well explained <code>BUILD_THREAD_UNSAFE</code>
<a href="https://github.com/basiliscos/cpp-rotor/">rotor</a> build option. Technically
it means, that <a href="https://www.boost.org/doc/libs/1_78_0/libs/smart_ptr/doc/html/smart_ptr.html#intrusive_ptr">boost&#39;s intrusive ptr</a>
is used in thread-unsafe manner, i.e. the underlying reference counter
is not atomic. Accordingly, all objects (in our case messages and actors from
<code>rotor</code>) cannot be accessed from different threads concurrently.</p>

<p>It should be explicitly mentioned, that rotor&#39;s cross-thread messaging facility
also cannot be used, otherwise there is notorious UB (undefined behavior).</p>

<p>Practically that usually means, that you are building single-threaded
application, most likely a service with asio/ev backend.</p>

<p>Why you might need that feature? <strong>Performance</strong> is the answer, i.e.
when you need rotor supervising/messaging facilities in single-threaded app.
According to my measurements, with the thread-unsafety you&#39;ll get <strong>~30.8</strong>
millions of messages per second instead of <strong>~23.5</strong> with the feauture disabled,
i.e. ~30% of performance boost for free.</p>

<p>The question arises, then, how to stop that single threaded application?
With the thread safety it can be done via launching additional thread, which
monitors some <em>atomic flag</em>, and, once it detects that it is set, it sends
shutdown signal to the root supervisor. The <em>atomic flag</em> is set externally,
i.e. in signal handler (NB: you cannot send shutdown message within
signal handler as all memory allocations are prohibited).</p>

<pre><code>...
struct sigaction action;
memset(&amp;action, 0, sizeof(action));
action.sa_handler = [](int) { shutdown_flag = true; };
auto r = sigaction(SIGINT, &amp;action, nullptr);
...
auto console_thread = std::thread([&amp;] {
    while (!shutdown_flag) {
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
    supervisor-&gt;shutdown();
});

supervisor-&gt;start();
io_context.run();
console_thread.join();
</code></pre>

<p>However, this is no longer possible with thread-unsafety option. What
can be done instead, is periodical flag checking from the rotor
thread itself, i.e. using timers from root supervisor. I found that
I use that feature frequently, so I decided to include it in 
<a href="https://github.com/basiliscos/cpp-rotor/">rotor</a>: in supervisor
builder there is needed to specify reference to the shutdown_flag
and the frequency of checking it, i.e.:</p>

<pre><code>rth::system_context_thread_t ctx;
auto timeout = r::pt::milliseconds{100};
auto sup = ctx.create_supervisor&lt;rth::supervisor_thread_t&gt;()
               .timeout(timeout)
               .shutdown_flag(shutdown_flag, timeout / 2)
               .finish();
</code></pre>

<p>(You still need to have to set it externally, like in the example
above with <code>sigaction</code> call). When it detects the flag is set to
<code>true</code> it shuts self down.</p>

<p><code>BUILD_THREAD_UNSAFE</code> is turned off by default. You should explicitly turn
it on if you are knowning what you are doing.</p>



</article>
<article>
    <header>
        <h1><a href="/blog/2022/02/20/supervising-in-c-how-to-make-your-programs-reliable/">Supervising in C++: how to make your programs reliable</a></h1>

        <aside>
            <time datetime="2022-02-20">
                Posted on 2022-02-20
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
        </p>

    </header>

    <h2>Supervising in real world</h2>

<p>When some extraordinary situation is met it can be handled at the problem level
or its handling can be delegated to some upper level. Usually, when it
is really extraordinary, it is delegated or ... it becomes exception handling.</p>

<p>Imagine, you are in a supermarket, and suddenly smoke and fire appear and for some
reason there is no fire alert signals. What would you do? You can try to
extinguish fire by yourself, or notify a supermarket employee about the problem and
let he handle the situation. It is likely an employee has codified instructions to
notify his direct manager or a fire service.</p>

<p>The key point here is that the extraordinary situation is not handled by you, but
by a person, who knows how to deal with it. Of course, you can try to handle it
by your own, but there might be consequences if you are not the person,
responsible for the situation.</p>

<h2>Supervising in backend and end-user services</h2>

<p>All non-trivial programs have bugs, however most of well-known cloud services are run
smoothly and we rarely notice them. This happens, because our programs are
externally supervised by devops programs like <code>systemd</code> or <code>runit</code>. Simplified, their
job can be described as following: if a program &quot;hangs&quot; kill it and start again,
if it exited, just restart it. In any case it leads to program <em>restart</em>.</p>

<p>There is, probably, the hardware supervising team too, and conceptually its job is
similar: if a router or server rack does not operate properly, turn it off and then
turn it on, i.e. <em>restart</em>.</p>

<p>For the regular end user of desktop application the situation is similar: when a
program misbehaves, it is terminated by the user or its operating system, and then,
probably the program will be started again by the user.</p>

<p>Despite different domains, the universal pattern is the same: give the buggy
application another chance by restarting it.</p>

<h2>Why there is no supervising in common C/C++/C#/Java/Perl/... programs</h2>

<p>Did you frequently see a desktop program, which works with network, and, when you
suddenly plug off the network cable (or turn off wifi router), it continues to
operate with some disabled functions, and when you plug the cable back in, the
program becomes fully operational as if there was no emergency at all?</p>

<p>Did you frequently see a backend app, which can easily outlive the loss of
connection to a database or messages queue or other critical resource? My experience
tells me, that level of error handling is very rare, and usually is not even
discussed.</p>

<p>&quot;We are not in the military/healthcare/aerospace/nuclear domain&quot;. That is true, in
short. A little bit more verbose and technical answer is: handling all that
exceptional cases requires writing additional <strong>special code</strong>, which is extremely
difficult to test (manually or automatically), it will significantly increase code
development and maintenance costs without any significant benefits...</p>

<h2>Actors as a solution</h2>

<p><a href="https://en.wikipedia.org/wiki/Actor_model_theory">Actor</a> is an independent entity with
its own lifetime and state, all the interaction with an actor happens only via
messaging, including actor start and stop signal. Thus, if something bad happens,
e.g., actor enters error state, it shuts self down and sends appropriate
message to its supervisor actor.</p>

<p>Let&#39;s emphasize the point: all communications with an actor are performed via messaging,
and if something wrong occurs, there will be appropriate message too, i.e. messaging
is universal.</p>

<p>The normal flow looks like the following (consumer point of view): client-actor sends
a request message to service-actor, and when the request processing by the service-actor
is completed, the response message is sent back to the client. The supervisor of the
service-actor does not participate in the communications; the same as in real life.</p>

<p>The error flow looks like the following from consumer point of view: client-actor sends
a request message to service-actor, and it receives a response with error from
the service-actor or, if something really terrible has happend, request timeout triggers,
which is conceptually the same as receive message with error. The service-actor,
however, has a few possibilities: if there is a problem with request, it can just
reply with error code; if there is an unrecoverable problem during error processing,
it can reply back with error to the client-actor and shut self down, i.e. send <code>down</code>
message to its supervisor.</p>

<p>Thus, the error flow is &quot;doubled&quot;: (1) the client receives error and takes its own
decision what to do with error and (2) the supervisor decides how to deal with
an actor&#39;s shutdown. Supervisor&#39;s decision is usually either to restart the problematic
actor (which originally triggered the error), or, if (possibly a several) restarts
do not fix the problem (i.e. service-actor still shuts self down), <strong>escalate the
problem</strong>, which means, to shut the supervisor down, to shutdown all child actors,
and then send <code>down</code> message to the <em>upstream supervisor</em> for further making decisions.</p>

<p>This approach is very different from widely used <em>exception handling</em>, where there is
a context for handling immediate error (1), but there isn&#39;t a context for supervising (2).
This is not accidental, because <em>using the service</em> (client role) is different from
<em>owning the service</em> (supervising role).</p>

<p>A few questions might arise.</p>

<p><strong>How to cope with unexpected or fatal errors?</strong> In theory, it is possible not to
handle this errors manually (with code) at all, just specifying restart policy for
the chosen framework/platform should be enough. It will simply just keep trying with
restarts until some reasonable limit is reached, then escalate the problem, restarting
the hierarchy of actors an so on... until it is solved, that after all possible attempts
have been tried and further trying has no sense, and the problem should be escalated
<em>outside</em> of the program, e.g. to human or to operating system.</p>

<p><strong>OK, the service-actors are keeping restarting (supervisor side), does it affect
client side?</strong> If it is OK for a client side to receive timeout responses when
service-actors have already been down and have not been started yet, then the answer is &quot;<strong>no</strong>&quot;.
The technical explanation is, that the message destination endpoint is not
bind to the concrete actor: in <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>
any actor can subscribe to any address, in
<a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> any agent can subscribe
to any message box.</p>

<p><strong>Does supervising tolerates developer errors?</strong> It depends on chosen platform. For
the Erlang case, with its <a href="https://wiki.c2.com/?LetItCrash">let it crash</a> principle,
developer errors lead to an actor crash, and supervisor can make further decision.
For the C++ errors like use-after-free or null pointer dereference or memory leaks
cannot be &quot;catch&quot;, so they are not recoverable and program crash or memory abuse
should be supervised externally by operating system or launchers like <code>systemd</code>.</p>

<p><strong>Can you give more practical examples?</strong> Sure. Consider there is a backend
application, which has a fast distributed cache and slow network connection to
a database. Can the app continue to serve, if the connection is suddenly gone?
<em>May be</em>, if it is OK to serve read-only requests via cache, trying to reconnect
to DB &quot;in background&quot;; this might be better than just cold restarts of the
whole app via system manager. Even if it cant, the time to become operational for
the app is fasten than the cold restart, because there is no need of cache reloading.
Can the app continue to serve, if the connection to network cache is lost?
<em>Surely</em>, it can serve a bit slower is better and it is better than a cold restart.
If backend and cache connections handling does not cost a lot in terms
of development and maintenance, the approach is definitely worth.</p>

<h2>The price</h2>

<p>Supervising is not free of charge. If you chose <a href="https://www.erlang.org/">Erlang</a> as
a platform, you receive the maximum flexibility in supervising, including tolerance
up to let-it-crash and possibility to send messages transparently to actors located
on non-local machine. However, the price is quite high, as you have to use rather
specific erlang language, the platform itself is slow comparing to native binaries
you get when you use C++/Go etc., and, if you want to speed up hot code path via
writing native extensions, you immediately loose all the benefits of the platform.
Somewhat specific syntax can be mitigated by using <a href="https://elixir-lang.org/">Elixir</a>
language.</p>

<p>In any case the messaging have to be used for actor environment, and it is not as
fast as native methods call: the memory for a message have to be allocated, the
message fields have to be filled, the message has to be dispatched etc. In summary
a message delivery can be hundred or more times expensive than a native call.</p>

<p>Another indirect costs of using messaging are that a framework has to be used,
because sending messages and especially receiving them cannot be performed without a
context. For C++ it can be <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>,
<a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> or
<a href="https://actor-framework.org/">C++ actor framework</a>, while erlang it itself
a platform and a framework (OTP).</p>

<p><strong>So, what is the total cost ownership of supervising?</strong> In theory it is nearly
zero cost in terms of writing special code (it should be done for you), but
you will be bounded to the platform/framework and the usage of messaging also
has its own performance price.</p>

<h2>Technical details of supervising in C++</h2>

<p><a href="https://actor-framework.org/">C++ actor framework</a> (aka CAF) is considered the
most influenced by <a href="https://www.erlang.org/">Erlang</a>, however, the supervising
itself is missing in it. CAF is capable  to run a cluster of nodes, each one can run
arbitrary number of actors. The strong point of CAF is <em>transparent messaging</em>
(actor addressing), i.e. when a message can be sent from one actor to another,
independently from their locations, i.e. they can be located on different
machines, on the same machine, or in the same process.</p>

<p>The situation with supervising is slightly better with
<a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>, as it provides
entity named <code>cooperation</code>, which has elemental supervising capabilities,
such as synchronized actors startup (shutdown): either all actors, belonging
to the same <code>cooperation</code>, do all start or no actor starts; and, similar,
if an actor from <code>cooperation</code> stops, all actors on the same cooperation
stop. It should be noted, that <code>cooperation</code> class is completely belongs
to the <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> framework,
and it is not possible to override something in it or somehow customize.
It is possible to hook actor shutdown event, and send shutdown notification
message somewhere, but that&#39;s a bit wrong way of building
supervising as it requires to handle a lot of things in your actors, which
is violation of
<a href="https://en.wikipedia.org/wiki/Single-responsibility_principle">Single Responsibility Principle</a>.
With <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> you can
construct hierarchical finite state machines, which are tightly integrated
with messaging, or you can use go-like channels for messaging. So,
it is still good framework if you need those features.</p>

<p>Supervising is one of the key features of <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>
since the beginning. There is the <code>supervisor_t</code> class, which manages
its child-actors; it is fully customizable, i.e. child-actor start
and stop events can be hooked etc. However, real erlang-like
<a href="https://www.erlang.org/doc/design_principles/sup_princ.html">supervising</a>
was not part of the microframework until <code>v0.20</code>. In short, since <code>v0.20</code>
it is possible to</p>

<p>1) declaratively specify failure escalation of each actor upon it&#39;s
construction:</p>

<pre><code>supervisor-&gt;create_actor&lt;actor_type&gt;()
    .timeout(timeout)
    .escalate_failure()        /* will shut down in error case */
    .finish();
</code></pre>

<p>2) declaratively respawn stopped actor, until some condition is
met, and, otherwise escalate failure</p>

<pre><code>namespace r = rotor;
auto actor_factory = [&amp;](r::supervisor_t &amp;supervisor, const r::address_ptr_t &amp;spawner) -&gt; r::actor_ptr_t {
    return sup
        .create_actor&lt;actor_type&gt;()
        .timeout(timeout)
        // other actor properties, probably taken from supervisor
        .spawner_address(spawner)
        .finish();
};

supervisor-&gt;spawn(actor_factory)
    .max_attempts(15)                               /* don&#39;t do that endlessly */
    .restart_period(boost::posix_time::seconds{10})
    .restart_policy(r::restart_policy_t::fail_only) /* respawn only on failure */
    .escalate_failure()                             /* we did our best, shutdown supervisor */
    .spawn();
</code></pre>

<p>The full example of the spawner pattern for ping-pong (where pinger-actor shuts self
down upon unsuccessful <code>pong</code> reply) can be seen
<a href="https://github.com/basiliscos/cpp-rotor/blob/master/examples/thread/ping-pong-spawner.cpp">here</a>.</p>

<h2>Conclusion</h2>

<p>If something went wrong in your program, give that piece of program another
chance, <strong>restart</strong> it. Maybe it was a temporal network issue, and it can disapper
with the next attempt; just wait a little bit and try again, but don&#39;t be too
assertive. One of the possible ways of organizing your program, into that
self-contained pieces, with own resources and lifetime, is to model them as
<a href="https://en.wikipedia.org/wiki/Actor_model_theory">actors</a>, which communicate
with each other via <strong>messaging</strong>. Shape the individual actors into manageable
hierarchies with <strong>supervisors</strong>, which provide fine-gained control of actors
at a low-level and at a high-level. Make your program reliable.</p>

<p><img alt="terminator.jpg" src="/blog/2022/02/20/supervising-in-c-how-to-make-your-programs-reliable/terminator.jpg"></p>



</article>
<article>
    <header>
        <h1><a href="/blog/2020/10/08/rotor-v0.09-release/">rotor v0.09 release</a></h1>

        <aside>
            <time datetime="2020-10-08">
                Posted on 2020-10-08
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
        </p>

    </header>

    <p>The original article was published at <a href="https://habr.com/">habr.com</a> in <a href="https://habr.com/ru/company/crazypanda/blog/522588/">English</a> and <a href="https://habr.com/ru/company/crazypanda/blog/522892/">Russian</a>. Due to outstanding changes I decided to write a decicated article explaining <code>rotor</code> and key points in a new release.</p>

<p><a href="https://github.com/basiliscos/cpp-rotor">rotor</a> is a <a href="https://basiliscos.github.io/cpp-rotor-docs/md__home_b_development_cpp_cpp-rotor_docs_Rationale.html">non-intrusive</a> event loop friendly C++ actor micro framework, similar to its elder brothers like <a href="https://actor-framework.org/">caf</a> and <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>. The new release came out under the flag of <strong>pluginization</strong>, which affects the entire lifetime of an actor.</p>

<h2>Actor Linking</h2>

<p>The actor system is all about interactions between actors, i.e. sending messages to each other (and producing side effects for the outer world or listening to messages it produces). However, to let a message be delivered to the final actor, the actor should <strong>be alive</strong> (1); in other words, if actor <code>A</code> is going to send message <code>M</code> to actor <code>B</code>, <code>A</code> should somehow be sure that actor <code>B</code> is online and will not go offline while <code>M</code> is routing.</p>

<p>Before <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> <code>v0.09</code>, that kind of warranty was only available due to child-parent relations, i.e. between supervisor and its child-actor. In this case, an actor was guaranteed that a message would be delivered to its supervisor because the supervisor <em>owned</em> the actor and said supervisor&#39;s lifetime covered the respective actor&#39;s lifetime. Now, with the release of <code>v0.09</code>, it is possible to link actor <code>A</code> with actor <code>B</code> that are not parent- or child-related to one another and to make sure that all messages will be delivered after successful linking .</p>

<p>So, linking actors is performed somewhat along these lines:</p>

<pre><code>namespace r = rotor;

void some_actor_t::on_start() noexcept override {
    request&lt;payload::link_request_t&gt;(b_address).send(timeout);
}

void some_actor_t::on_link_response(r::message::link_response_t &amp;response) noexcept {
    auto&amp; ec = message.payload.ec;
    if (!ec) {
        // successful linking
    }
}
</code></pre>

<p>However, code like this should not be used directly as is... because it is inconvenient. It becomes more obvious if you try linking actor <code>A</code> with 2 or more actors (<code>B1</code>, <code>B2</code>, etc.), since <code>some_actor_t</code> should keep an internal count of how many target actors are waiting for (successful) link responses. And here the pluginization system featured in the <code>v0.09</code> release comes to the rescue:</p>

<pre><code>namespace r = rotor;

void some_actor_t::configure(r::plugin::plugin_base_t &amp;plugin) noexcept override {
    plugin.with_casted&lt;r::plugin::link_client_plugin_t&gt;(
        [&amp;](auto &amp;p) {
            p.link(B1_address);
            p.link(B2_address);
        }
    );
}
</code></pre>

<p>Now, this is much more convenient, since <code>link_client_plugin_t</code> is included out of the box with the <code>rotor::actor_base_t</code>. Nevertheless, it&#39;s still not enough, because it does not answer a few important questions, such as: 1. When is actor linking performed (and a &quot;by-question&quot;: when is actor <strong>unlinking</strong> performed)? 2. What happens if the target actor (aka &quot;server&quot;) does not exist or rejects linking? 3. What happens if the target actor decides to self-shutdown when there are &quot;clients&quot; still linked to it?</p>

<p>To provide answers to these questions, the concept of actor lifetime should be revisited.</p>

<h2>Async Actor Initialization And Shutdown</h2>

<p>Represented in a simplified manner is, here is how an actorâ€™s state usually changes: <code>new</code> (constructor) -&gt; <code>initializing</code> -&gt; <code>initialized</code> -&gt; <code>operational</code> -&gt; <code>shutting down</code> -&gt; <code>shut down</code></p>

<p>The main job is performed in the <code>operational</code> state, and it is up to the user to define what an actor is to do in its up-and-running mode.</p>

<p>In the <strong>I-phase</strong> (i.e. <code>initializing</code> -&gt; <code>initialized</code>), the actor should prepare itself for further functioning: locate and link with other actors, establish connection to the database, acquire whichever resources it needs to be operational. The key point of <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> is that I-phase is <strong>asynchronous</strong>, so an actor should notify its supervisor when it is ready (2).</p>

<p>The <strong>S-phase</strong> (i.e. <code>shutting down</code> -&gt; <code>shut down</code>) is complementary to the <strong>I-phase</strong>, i.e. the actor is being asked to shut down, and, when it is done, it should notify its supervisor.</p>

<p>While it sounds easy, the tricky bit lies in the <strong>composability</strong> of actors, when they form Erlang-like hierarchies of responsibilities (see my article on <a href="https://basiliscos.github.io/blog/2019/08/19/cpp-supervisors/">trees of Supervisors</a>). In other words, any actor can fail during its <code>I-phase</code> or <code>S-phase</code>, and that can lead to asynchronous collapse of the entire hierarchy, regardless of the failed actor&#39;s location within it. Essentially, the entire hierarchy of actors becomes <code>operational</code>, or, if something happens, the entire hierarchy becomes <code>shut down</code>.</p>

<p><a href="https://github.com/basiliscos/cpp-rotor">rotor</a> seems unique with its init/shutdown approach. There is nothing similar in <a href="https://actor-framework.org/">caf</a>;
in <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a>, there is a <a href="https://sourceforge.net/p/sobjectizer/wiki/so5extra%201.0%20Shutdowner/">shutdown helper</a>, which
carries a function similar to the <code>S-phase</code> above; however, it is limited to one actor only and offers no <code>I-phase</code> because <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> has no concept of hierarchies (see <strong>update</strong> below).</p>

<p>While using <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>, it was discovered that the progress of the <code>I-phase</code> (<code>S-phase</code>) may potentially require <em>many</em> resources to be acquired (or released) asynchronously, which means that no single component, or actor, is able, by its own will, to answer the question of whether it has or has not completed the current phase. Instead, the answer comes as a result of collaborative efforts, handled in the right order. And this is where <strong>plugins</strong> come into play; they are like pieces, with each one responsible for a particular job of initialization/shutdown.</p>

<p>So, here are the promised answers related to <code>link_client_plugin_t</code>:</p>

<ul>
<li>Q: When is the actor linking or unlinking performed? A: When the actor state is <code>initializing</code> or <code>shutting down</code> respectively.</li>
<li>Q: What happens if the target actor (aka &quot;server&quot;) does not exist or rejects linking? A: Since this happens when the actor state is <code>initializing</code>, the plugin will detect the fail condition and will trigger client-actor shutdown. That may trigger a cascade effect, i.e. its supervisor will be triggered to shut down, too.</li>
<li>Q: What happens if the target actor decides to self-shutdown when there are &quot;clients&quot; still linked to it? A: The &quot;server-actor&quot; will ask its clients to unlink, and once all &quot;clients&quot; have confirmed unlinking, the &quot;server-actor&quot; will continue the shutdown procedure (3).</li>
</ul>

<h2>A Simplified Example</h2>

<p>Let&#39;s assume that there is a database driver with async-interface with one of the available event-loops for <code>rotor</code>, and there will be TCP-clients connecting to our service. The database will be served by <code>db_actor_t</code> and the service for serving clients will be named <code>acceptor_t</code>. The database actor is going to look like this:</p>

<pre><code>namespace r = rotor;

struct db_actor_t: r::actor_base_t {

    struct resource {
        static const constexpr r::plugin::resource_id_t db_connection = 0;
    }

    void configure(r::plugin::plugin_base_t &amp;plugin) noexcept override {
        plugin.with_casted&lt;r::plugin::registry_plugin_t&gt;([this](auto &amp;p) {
            p.register_name(&quot;service::database&quot;, this-&gt;get_address())
        });
        plugin.with_casted&lt;r::plugin::resources_plugin_t&gt;([this](auto &amp;) {
            resources-&gt;acquire(resource::db_connection);
            // initiate async connection to database
        });
    }

    void on_db_connection_success() {
        resources-&gt;release(resource::db_connection);
        ...
    }

    void on_db_disconnected() {
        resources-&gt;release(resource::db_connection);
    }

    void shutdown_start() noexcept override {
        r::actor_base_t::shutdown_start();
        resources-&gt;acquire(resource::db_connection);
        // initiate async disconnection from database, e.g. flush data
    }
};
</code></pre>

<p>The inner namespace <code>resource</code> is used to identify the database connection as a resource. It is good practice, better than hard-coding magic numbers like <code>0</code>. During the actor configuration stage (which is part of initialization), when <code>registry_plugin_t</code> is ready, it will asynchronously register the actor address under a symbolic name of <code>service::database</code> in the <code>registry</code> (will be shown further down below). Then, with the <code>resources_plugin_t</code>, it acquires the database connection resource, blocking any further initialization and launching connection to the database. When connection is established, the resource is released, and the <code>db_actor_t</code> becomes <code>operational</code>. The <code>S-phase</code> is symmetrical, i.e. it blocks shutdown until all data is flushed to DB and connection is closed; once this step is complete, the actor will continue its shutdown (4).</p>

<p>The client acceptor code should look like this:</p>

<pre><code>namespace r = rotor;
struct acceptor_actor_t: r::actor_base_t {
    r::address_ptr_t db_addr;

    void configure(r::plugin::plugin_base_t &amp;plugin) noexcept override {
        plugin.with_casted&lt;r::plugin::registry_plugin_t&gt;([](auto &amp;p) {
            p.discover_name(&quot;service::database&quot;, db_addr, true).link();
        });
    }

    void on_start() noexcept override {
        r::actor_base_t::on_start();
        // start accepting clients, e.g.
        // asio::ip::tcp::acceptor.async_accept(...);
    }

    void on_new_client(client_t&amp; client) {
        // send&lt;message::log_client_t&gt;(db_addr, client)
    }
};
</code></pre>

<p>The key point here is the <code>configure</code> method. When <code>registry_plugin_t</code> is ready, it is configured to discover the name <code>service::database</code> and, when found, store it in the <code>db_addr</code> field; it then links the actor to the <code>db_actor_t</code>. If <code>service::database</code> is not found, the acceptor shuts down (i.e. <code>on_start</code> is not invoked); if the linking is not confirmed, the acceptor shuts down, too. When everything is fine, the acceptor starts accepting new clients.</p>

<p>The operational part itself is missing for the sake of brevity because it hasn&#39;t changed in the new <code>rotor</code> version: there is a need to define payload and message (including request and response types), as well as define methods which will accept the messages and finally subscribe to them.</p>

<p>Let&#39;s bundle everything together in a <code>main.cpp</code>. Let&#39;s assume that the <code>boost::asio</code> event loop is used.</p>

<pre><code>namespace asio = boost::asio;
namespace r = rotor;

...
asio::io_context io_context;
auto system_context = rotor::asio::system_context_asio_t(io_context);
auto strand = std::make_shared&lt;asio::io_context::strand&gt;(io_context);
auto timeout = r::pt::milliseconds(100);
auto sup = system_context-&gt;create_supervisor&lt;r::asio::supervisor_asio_t&gt;()
               .timeout(timeout)
               .strand(strand)
               .create_registry()
               .finish();

sup-&gt;create_actor&lt;db_actor_t&gt;().timeout(timeout).finish();
sup-&gt;create_actor&lt;acceptor_actor_t&gt;().timeout(timeout).finish();

sup-&gt;start();
io_context.run();
</code></pre>

<p>The <code>builder</code> pattern is actively used in the <code>v0.09</code> <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>. Here, the root supervisor <code>sup</code> was created with 3 actors instantiated on it: the user defined <code>db_actor_t</code> and <code>acceptor_actor_t</code> and implicitly created a registry actor. As is typical for the actor system, all actors are decoupled from one another, only sharing message types (skipped here).</p>

<p>All actors are simply created here, and the supervisor does not know the relations between them because actors are loosely coupled and have become more autonomous since <code>v0.09</code>.</p>

<p>Runtime configuration can be completely different: actors can be created on different threads, different supervisors, and even using different event loops, but the actor implementation remains the same (5). In that case, there will be more than one root supervisor; however, to let them find each other, the <code>registry</code> actor address should be shared between them. This is also supported via the <code>get_registry_address()</code> method of <code>supervisor_t</code>.</p>

<h2>Summary</h2>

<p>The most important feature of <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> <code>v0.09</code> is the pluginization of its core. Among other <a href="https://basiliscos.github.io/cpp-rotor-docs/index.html">plugins</a>, the most important are: the <code>link_client_plugin_t</code> plugin, which maintains kind of a &quot;virtual connection&quot; between actors; the <code>registry_plugin_t</code>, which allows registering and discovering actor addresses by their symbolic names; and the <code>resources_plugin_t</code>, which suspends actor init/shutdown until external asynchronous events occur.</p>

<p>There are a few less prominent changes in the release, such as the new non-public properties <a href="https://basiliscos.github.io/blog/2020/07/23/permission-model/">access</a> and builder pattern for actor construction.</p>

<p>Any feedback on <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> is welcome!</p>

<p>PS. I&#39;d like to say thanks to Crazy Panda for supporting me in my actor model research.</p>

<h3>Notes</h3>

<p>(1) Currently, it will lead to segfault upon attempt to deliver a message to an actor whose supervisor is already destroyed.</p>

<p>(2) If it does not notify, init-request timeout will occur, and the actor will be asked by its supervisor to shut down, i.e. bypass the <code>operational</code> state.</p>

<p>(3) You might ask: what happens if a client-actor does not confirm unlinking on time? Well, this is somewhat of a violation of contract, and the <code>system_context_t::on_error(const std::error_code&amp;)</code> method will be invoked, which, by default, will print error to <code>std::cerr</code> and invoke <code>std::terminate()</code>. To avoid contract violation, shutdown timeouts should be tuned to allow client-actors to unlink on time.</p>

<p>(4) During shutdown, the <code>registry_plugin_t</code> will unregister all registered names in the <code>registry</code>.</p>

<p>(5) With the exception of when different event loops are used, when actors use the event loop API directly, they will, obviously, change following the event loop change, but that&#39;s beyond <a href="https://github.com/basiliscos/cpp-rotor">rotor</a>.</p>

<h3>Update</h3>

<p>During discussings with <code>sobjectizer</code> author below, it was clarified <code>sobjectizer</code> <a href="https://github.com/Stiffstream/so5extra/wiki/so5extra-1.4-Shutdowner">shutdowner</a> and <a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5.19%20Stop%20guards/">stop guard</a> offer &quot;long lasting&quot; shutdown actions, however it&#39;s main purpose to give some actors additional time for shutdown, even if on the <code>Environment</code> <code>stop</code> was invoked. The asynchronous shutdown (and initialization) similar to <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> <code>I-phase</code> and <code>S-phase</code> can be modeled via actor&#39;s states, if needed. This is, however, framework <strong>users</strong> responsibility, contrary to <code>rotor</code>, where it is <strong>the framework</strong> responsibility.</p>



</article>
<article>
    <header>
        <h1><a href="/blog/2020/07/23/permission-model/">C++ permission model</a></h1>

        <aside>
            <time datetime="2020-07-23">
                Posted on 2020-07-23
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
        </p>

    </header>

    <h1>Abstract</h1>

<p>The problems of <code>public</code>, <code>protected</code> and <code>private</code> access are considered.
The generic templated <code>access</code> approach  with the on-demand specialization
for a consumer is proposed; it&#39;s advantages and drawbacks are discussed.
The synthetic solution satisfactory enough is proposed in the conclusion.</p>

<h1>The problem</h1>

<p>Out of the box C++ offers &quot;classical&quot; class access model: <code>public</code> properties
(fields and methods) are accessible from anywhere, <code>protected</code> properties
are accessible to descendant classes only, and finally <code>private</code> properties
which permit access to class itself only.</p>

<p>Additionally it is possible to declare <code>friend</code> class (which might be templated)
to provide maximum access to all properties (i.e. the same as <code>private</code>). This
allows to access to the internals of a class to a <strong>related</strong> class.</p>

<p>For example, if there is an HTTP-library with <code>Request</code> and <code>Connection</code> classes
and <code>Request</code> class would like to access <code>Connection</code> internals, this can be done
as:</p>

<pre><code>class Request;  /* forward declare */

enum class Shutdown { read, write, both };
class Connection {
    public:
        virtual void handle() { ... }
    private:
        void shutdown(Shutdown how) { ...;  }
        int skt;
        friend class Request;
};

class Request {
    public:
        virtual void process() {
            ...;
            /* I know what I&#39;m doing */
            conn-&gt;shutdown(Shutdown::both);
        }
    protected:
      Connection* conn;
};
</code></pre>

<p>Now let&#39;s assume that there is an descendant</p>

<pre><code>class HttpRequest: public Request {
    public:
        virtual void process() override {
            conn-&gt;shutdown(Shutdown::both); // Oops!
        }
};
</code></pre>

<p>Alas, there is no way in C++ to access to <code>Connection::shutdown</code> from it.
To overcome this, with the current access model, there are the possibilities.
<em>First</em>, it is possible to declare <code>HttpRequest</code> as a friend in the <code>Connection</code>.
Whilst this will certainly work, the solution has strict limitation, that it
applicable only for single library (project) to code of which you have access.
Otherwise, <em>it does not scales at all</em>.</p>

<p>The <em>second</em> possibility if is to &quot;expose&quot; private connection from the <code>Request</code>
class to all it&#39;s descendants, like:</p>

<pre><code>class Request {
    protected:
        void connection_shutdown(Shutdown how) {  conn-&gt;shutdown(how); }
        int&amp; connection_socket() {  conn-&gt;skt; }
        const int&amp; connection_socket() const {  conn-&gt;skt; }
        Connection* conn;
};
</code></pre>

<p>This approach is better, because it scales to all descendant classes which can
be located in different libraries. However, the price is quite high as there
is need to provide access to all properties apriori even if some properties
will not be needed. The more serious drawback is that the approach is limited
to class inheritance; in other words, if there is need to access private
properties of <code>Connection</code> not from <code>Request</code>&#39;s descendants, e.g. for tests.</p>

<p>Somebody might become disappointed at all and try to make everything <strong>public by
default</strong>. This scales well and covers all abovedescribed issues though brings
a new ones: the boundary between stable <em>public</em> API interface and <em>private</em>
implementation details of a class is blurred and completion suggestions in
an IDE can be overloaded with too many variants. In other words the proposed
approach is <em>too permissive</em>.</p>

<p>Semantically identical would be to write simple <strong>accessors for all private
properties</strong>; it just brings an <em>illusion</em> of the interface/implementation
separation since a class author already exposed all class internals outside.</p>

<p>Let&#39;s summarize the requirements for the private properties (aka implementation
details):</p>

<ul>
<li><p>they should scale outside of a library</p></li>
<li><p>they should be accessible outside of class hierarchy</p></li>
<li><p>they should not &quot;pollute&quot; the class public API, i.e. somehow be not
available by default, still be accessible</p></li>
</ul>

<h1>The possible solutions</h1>

<p>It consists of two pieces, the first one is to declare possibility to access
the private fields of a class, e.g.:</p>

<pre><code>// my_library.h
namespace my::library {
    class Connection {
        public:
            virtual void handle() { ... }
            template&lt;typename T...&gt; auto&amp; access() noexcept;
        private:
            void shutdown(Shutdown how) { ...;  }
            int skt;
    };
}
</code></pre>

<p>The second piece is actually provide full access specialization in the
target place, e.g. :</p>

<pre><code>// my_app.cpp
namespace to {
    struct skt{}; // matches private field
}

namespace my::library {
    auto&amp; Connection::access&lt;to::skt&gt;() noexcept { return skt; }
}

// namespace does not matter
class HttpRequest: public Request {
    public:
        virtual void process() override {
            auto&amp; s = conn-&gt;access&lt;to::skt&gt;();  // voila!
            shutdown(s, SHUT_RDWR);
        }
};
</code></pre>

<p>In other words, in the source class the generic templated accessor
is defined, and in the place, where the access is needed, the specialization
is provided as the actual access to the required fields.</p>

<p>The solution meets all requirements, however it still has it&#39;s own drawbacks.
First, there is need of duplication of <code>const</code> and <code>non-const</code> access, i.e.</p>

<pre><code>class Connection {
    public:
        virtual void handle() { ... }
        template&lt;typename T...&gt; auto&amp; access() noexcept;
        template&lt;typename T...&gt; auto&amp; access() const noexcept;
};

...

namespace my::library {
    auto&amp; Connection::access&lt;to::skt&gt;() noexcept       { return skt; }
    auto&amp; Connection::access&lt;to::skt&gt;() const noexcept { return skt; }
}
</code></pre>

<p>Although, you don&#39;t have to provide <code>const</code> and <code>non-const</code> access if you need
only one.</p>

<p>The second drawback, that to let the approach work <em>for methods</em>, especially
those, which return type can&#39;t be <code>auto&amp;</code> (e.g. <code>void</code> or <code>int</code>). To overcome
it the <code>access</code> should be rewritten as:</p>

<pre><code>class Connection {
    public:
        template&lt;typename T, typename... Args&gt; T access(Args...);
}

namespace my::library {
    void Connection::access&lt;void, Shutdown&gt;(Shutdown how) {
        return shutdown(how);
    }
}

class HttpRequest: public Request {
    public:
        virtual void process() override {
            conn-&gt;access&lt;void, Shutdown&gt;(Shutdown::both);
        }
};
</code></pre>

<p>Another problem arises: if there are two or more private methods with identical
signatures (return and arguments types), the artificial tag should be introduced
again, i.e.</p>

<pre><code>class Connection {
    template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...);
};

namespace to {
    struct skt{};
    struct shutdown{};
}

namespace my::library {
    int&amp; Connection::access&lt;int&amp;, to::skt&gt;() { return skt; }
    void Connection::access&lt;void, to::shutdown, Shutdown&gt;(Shutdown how) {
        shutdown(how);
    }
}

...
conn-&gt;access&lt;void, to::shutdown&gt;(Shutdown::both); // voila!
</code></pre>

<p>The variadic <code>Args...</code> template parameter dos not force to duplicate the original
arguments; it can have even add unrelated types to &quot;inject&quot; new methods with additional
logic into the <code>Connection</code> class. For example:</p>

<pre><code>namespace to {
    struct fun{}
}

namespace my::library {
    void Connection::access&lt;void, to::fun&gt;() {
        Shutdown how = std::rand() &gt; 1000 ? Shutdown::read ? Shutdown::write;
        shutdown(how);
    }
}
</code></pre>

<p>It is known, that methods might have optional <code>noexcept</code> specification in addition
to <code>const</code>. So, for the sake of generality, all four access cases should be
provided, i.e.:</p>

<pre><code>class Connection {
public:
template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...);
template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...) const;
template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...) noexcept;
template&lt;typename T, typename Tag, typename... Args&gt; T access(Args...) const noexcept;
};
</code></pre>

<p>Alas, it was not the last problem with the approach: there is a problem with inheritance,
e.g.:</p>

<pre><code>class Connection {
    template&lt;typename T&gt; auto&amp; access();
private:
    int skt;
};

enum class SslState { /* whatever */};

class SslConnection:public Connection {
public:
    template&lt;typename T&gt; auto&amp; access();
private:
    SslState state;
};

namespace to {
    struct skt{};
    struct state{};
}

namespace my::library {
    auto&amp; Connection::access&lt;to::skt&gt;() { return skt; }
    auto&amp; SslConnection::access&lt;to::state&gt;() { return state; }
}
</code></pre>

<p>However, as soon as try to access to parent property via child class, i.e.:</p>

<pre><code>SslConnection* conn = ...;
auto&amp; skt = conn-&gt;access&lt;to::skt&gt;(); // oops!
</code></pre>

<p>It cannot resolve access to socket via <code>SslConnection</code> because there is no
<code>to::skt</code> specialization for <code>SslConnection</code>; there is on in it&#39;s parent class,
but in accordance with C++ rules a compiler does not see it. The solution
is to cast to the base class:</p>

<pre><code>SslConnection* conn = ...;
auto&amp; skt = static_cast&lt;Connection*&gt;(conn)-&gt;access&lt;to::skt&gt;();
</code></pre>

<p>This becomes even more unhandy when an object is stored behind smart pointer.</p>

<p>Let&#39;s enumerate key points:</p>

<ul>
<li><p>accessors multiplication due to <code>const</code> and <code>noexcept</code> variants</p></li>
<li><p>not so handy access for private methods (too verbose due to multiple template
params), although &quot;injection&quot; of own accessor-methods seems an advantage</p></li>
<li><p>too clumpsy syntax to access private proreties in class hierarchy</p></li>
</ul>

<h1>Conclusion</h1>

<p>The proposed solution is far from perfect. I found the following golden ratio
for my projects on the implementation details access topic:</p>

<ul>
<li><p>if the property is stable enough or it is the part of class interface,
then public accessor should be written for it. It would be desirable for
read only access, i.e. the accessor should be just a getter. For example,
the <code>address</code> property in <code>actor_base</code> in
<a href="https://github.com/basiliscos/cpp-rotor/blob/master/include/rotor/actor_base.h">rotor</a>.</p></li>
<li><p>otherwise, if implementation details might be usable in descendants,
make them <code>private</code></p></li>
<li><p>provide generic templated accessor (<code>template&lt;typename T&gt; auto&amp; access()</code>)
but for properties only; no access to private methods, as I don&#39;t see possible
use cases now. This point might be different for different projects.</p></li>
</ul>

<p>The described approach is applied in to be released soon
<a href="https://github.com/basiliscos/cpp-rotor">rotor</a> <code>v0.09</code>.</p>



</article>
<article>
    <header>
        <h1><a href="/blog/2019/10/05/request-response-message-exchange-pattern/">Request Response Message Exchange Pattern</a></h1>

        <aside>
            <time datetime="2019-10-05">
                Posted on 2019-10-05
            </time>
                <span class="author">
                    by Ivan Baidakou (aka basiliscos)
                </span>
        </aside>

        <p class="tags">Tags:
            <a href="/blog/tag/c/" rel="tag">c++</a>
            <a href="/blog/tag/rotor/" rel="tag">rotor</a>
        </p>

    </header>

    <h1>Introduction</h1>

<p>The plan is to examine request/response pattern in &quot;abstract&quot; actor framework,
and find why it is not so trivial to implement as it might appear at the first.
Later, we&#39;ll see how various C++ actor frameworks (CAF, sobjectizer, rotor)
support the pattern.</p>

<p>The Request Response Message Exchange Pattern sounds quite simple: a <code>client</code>
asks a <code>server</code> to proccess a <code>request</code> and return <code>response</code> to the client
once it is done.</p>

<h1>Synchronous analogy</h1>

<p>This is completely artificial analogy, however it seem useful for further
explanations.</p>

<p>It can be said, that in synchronous request-response can be simply presented as
just a regular function call, where <em>request</em> is input parameter to a function,
and the <em>response</em> is the return type, i.e.</p>

<pre><code>struct request_t { ... };
struct response_t { ... };

response_t function(const request_t&amp;) {  ... }
</code></pre>

<p>The &quot;server&quot; here is the <code>function</code> inself, and the &quot;client&quot; is the call-side side.</p>

<p>The semantic of this function says that the function <strong>always</strong> successfully
processes a request and return a result.</p>

<p>Probably, the most modern way to express that a function might fail is to
wrap the response into monad-like wrapper,
like <a href="https://en.cppreference.com/w/cpp/utility/optional">std::optional</a>,
<a href="https://github.com/TartanLlama/expected">std::expected</a>,
<a href="https://www.boost.org/doc/libs/1_70_0/libs/outcome/doc/html/index.html">boost::outcome</a>
etc.</p>

<p>Probably, the mostly used way to let the caller know that request processing
failed is to throw an <em>exception</em>. However, it is not expressible in the modern C++,
so it should be mentioned somewhere in documentation or just assumed; in other
words, from the function signature <code>response_t function(const request_t&amp;)</code> never
knows whether it always successfully processes request or sometimes it might
fail and thrown an exception.</p>

<h1>Problems of naive approach in actor framework</h1>

<p>Let&#39;s realize the simple request-response approach within the imaginary actor
framework: the <code>on_request</code> method of server-actor is called with the request
payload, and it returns the <code>response_t</code></p>

<pre><code>response_t server_t::on_request(request_t &amp;)
</code></pre>

<p>The naive implementation of request-response approach follows the
same pattern as in synchronous analogy, when it &quot;forgets&quot; to express that
the request processing might fail. The actor framework responsibility is
to wrap payload (<code>response_t</code>, <code>request_t</code>) into messages (<code>message&lt;request_t&gt;</code>)
and deliver them as <em>messages</em> to related actors (client-actor, server-actor).
Later the payload will be unpacked.</p>

<p>The corresponding receiver interface of the client-actor will be like:</p>

<pre><code>void client_t::on_response(response_t&amp;)
</code></pre>

<p>While it looks OK, how will the client-actor be able to distinguish responses
from different requests?</p>

<p>The first solution would be to use some conventions on the request/response
protocol, i.e. inject some synthetic <code>request_id</code> into <code>request_t</code> and
somewhere into <code>response_t</code>, generate and set  it on request-side (client-actor)
and presume that the server-actor will set it back together with the response.
There is a variation of the solution, when the <code>request_t</code> is completely
embedded into <code>response_t</code>.</p>

<p>While this will definitely work as it will be shown below with <code>sobjectizer</code>
framework, this also means that <strong>there is no help from a actor framework</strong>
and the burden of the implementation lies completely on a developer.</p>

<p>The second solution is to let it be managed somehow by an actor framework:
let is suspend client-actor execution until the response will be received.
The &quot;suspending&quot; in the context means that all messages for the client-actor
will be queued until the response will be received.</p>

<p>This will work as soon as everything goes fine. However, as soon as something
goes wrong (i.e. server-actor cannot process the request), the whole client-actor
will stuck: It will not able to process <em>any</em> message, because it infinitely
waits the particular one (the response).</p>

<p>In terms of actor-design the client-actor becomes <strong>non-reactive</strong> at the moment
when it stops processing messages, which was a &quot;feature&quot; of the imaginary
naive actor framework to &quot;wait&quot; the <code>response</code>.</p>

<p>You might guess, the per-request timeout timer, can resolve the problem. Yes,
indeed, however how in the interface</p>

<pre><code>void client_t::on_response(response_t&amp;)
</code></pre>

<p>it is possible to tell client-actor about timeout trigger? I don&#39;t see an
acceptable way to do that. It is paradoxical situation, that a failure
can be detected, but there is no way to react on it.</p>

<p>Anyway, even if there would be a way to notify client-actor about failure,
it still does not completely solves the non-reactivity problem: an actor
becomes reactive only after timeout trigger, and until that it is still
&quot;suspended&quot; waiting <code>response_t</code> or timeout trigger.</p>

<p>The root of the problem caused by &quot;forgetfulness&quot; of the server-actor
interface to specify, that it might fail. It&#39;s time to review our interfaces,
then.</p>

<h1>No framework support for req/res pattern</h1>

<p>Let&#39;s summarize the necessary pieces, which are required to implement
request/response pattern in actor-like manner.</p>

<p>First, the server-actor might fail in processing the request, and it
need to tell the framework and client-actor about the failure.</p>

<p>Second, the response should enriched to contain the original <code>request_id</code>
to make it possible for client-actor to map the response to the request.
(In other sources it might be named <code>correlation_id</code>, which serves the
same purpose).</p>

<p>Third, the original request from the client-actor should also contain
the <code>request_id</code>.</p>

<p>Forth, as the original response payload might be missing at all, it
should be wrapped monad-like container (<code>std::optional</code>, <code>std::unique_ptr</code>
etc.)</p>

<p>So, our basic structures should look like:</p>

<pre><code>struct request_t { ... };
struct response_t { ... };
using request_id_t = std::uint32; /* as as example */

struct wrapped_request_t {
    request_id_t request_id;
    request_t req;
};

enum class request_error_t { SUCCESS, TIMEOUT, FAIL_REASON_1_1, ... };

struct wrapped_response_t {
    request_error_t request_error;
    request_id_t request_id;
    std::optional&lt;response_t&gt; res;  /* may be it&#39;ll contain the payload */
};
</code></pre>

<p>And the corresponding actor interfaces will be:</p>

<pre><code>wrapped_response_t server_t::on_request(wrapped_request_t&amp; ) { ... }

void client_t::on_response(wrapped_response_t&amp; ) { ... }
</code></pre>

<p>The <code>FAIL_REASON_1_1</code> and other error codes are desirable, if the server
wants <strong>fail early</strong> and notify client about that. Otherwise, if server cannot
process request, it silently ignores the request; however client will be notified
only via timeout and it can only guess, what exactly was wrong. In other words,
it is not good practice in general <em>ignore</em> wrong requests; react on them is
much better.</p>

<p>So, sending an request from client to server should be like:</p>

<pre><code>struct client_t {
    ...
    request_id_t last_request_id = 1;
};

void client_t::some_method() {
    auto req_id = ++last_request_id;
    auto request = request_t{ ... };
    framework.send(server_address, wrapped_request_t{ req_id, std::move(request) } );
}
</code></pre>

<p>However, the story does not end here, as the timeout-timer part is missing (i.e.
for the case, when server-actor does not answer at all). The needed pieces are:
1) per request timeout timer; 2) when the response arrives in time, the timer
should be cancelled; 3) otherwise, the message with empty payload and timeout-fail
reason should be delivered;  4) if the response still arrives after timeout trigger,
it should be silently  discarded. There is a sense to have this things in dedicated methods.</p>

<pre><code>/* whatever that is able to identify particular timer instance */
using timer_id_t = ...;

struct client_t {
    using timer_map_t = std::unordered_map&lt;timer_id_t, request_id_t&gt;;
    /* reverse mapping */
    using request_map_t = std::unordered_map&lt;request_id_t, timer_id_t&gt;;
    ...
    request_id_t last_request_id = 1;
    timer_map_t timer_map;
    request_map_t request_map;
};

void client_t::some_method() {
    auto req_id = ++last_request_id;
    auto request = request_t{ ... };
    framework.send(server_address, wrapped_request_t{ req_id, std::move(request) } );
    /* start timer */
    auto timer_id = timers_framework.start_time(timeout);
    timer_map.emplace(timer_id, req_id);
    request_map.emplace(req_id, timer_id);
}

void client_t::on_timer_trigger(timer_id_t timer_id) {
    auto request_id = timer_map[timer_id];
    this-&gt;on_response(wrapped_response_t{ request_error_t::TIMEOUT,  request_id });
    timer_map.erase(timer_id);
    request_map.erase(request_id);
}

void client_t::on_response_guard(wrapped_response_t&amp; r) {
    if (request_map.count(r.request_id) == 0) {
        /* no timer, means timer already triggered and timeout-response was
        delivered, just discard the response */
        return;
    }
    auto timer_id = request_map[r.request_id];
    timers_framework.cancel(timer_id);
    this-&gt;on_response(r); /* actually deliver the response */
    timer_map.erase(timer_id);
    request_map.erase(request_id);
}
</code></pre>

<p>Now, the example is complete. It should be able to handle request-responses
in a robust way. However, there is no actual request processing code, and
a lot of auxiliary code to make it responsible and robust.</p>

<p>The worse thing, if that the boilerplate code have to be repeated for
every request-response pair type. It is discouraging and error-prone way
of development; an developer might end up frustrated with actor-design
at all.</p>

<h1>req/res approach with sobjectizer</h1>

<p>The <a href="https://github.com/Stiffstream/sobjectizer">sobjectizer</a> actor framework
at the moment has version <code>5.6</code> and does not help in request-response pattern
usage. So, basically, it is like the request-response sample above without
framework support, with sobjectizer&#39;s specifics, of course.</p>

<p>In the example below the &quot;probabilistic pong&quot; (<code>server</code> role) is used: i.e. randomly
it successfully answers to ping-requests, and sometimes it just ignores the
requests. The <code>pinger</code> (<code>client</code> role) should be able to detect the both cases.</p>

<pre><code>#include &lt;so_5/all.hpp&gt;
#include &lt;optional&gt;
#include &lt;random&gt;
#include &lt;unordered_map&gt;

using request_id_t = std::uint32_t;
using namespace std::literals;

struct ping {};

struct pong {};

struct timeout_signal {
    request_id_t request_id;
};

enum class request_error_t { SUCCESS, TIMEOUT };

struct wrapped_ping {
    request_id_t request_id;
    ping payload;
};

struct wrapped_pong {
    request_id_t request_id;
    request_error_t error_code;
    std::optional&lt;pong&gt; payload;
};

class pinger final : public so_5::agent_t {
    using timer_t = std::unique_ptr&lt;so_5::timer_id_t&gt;;
    using request_map_t = std::unordered_map&lt;request_id_t, timer_t&gt;;

    so_5::mbox_t ponger_;
    request_map_t request_map;
    request_id_t last_request = 0;

    void on_pong(mhood_t&lt;wrapped_pong&gt; cmd) {
        auto &amp;timer = request_map.at(cmd-&gt;request_id);
        timer-&gt;release();
        request_map.erase(cmd-&gt;request_id);
        on_pong_delivery(*cmd);
    }

    void on_pong_delivery(const wrapped_pong &amp;cmd) {
        bool success = cmd.error_code == request_error_t::SUCCESS;
        auto request_id = cmd.request_id;
        std::cout &lt;&lt; &quot;pinger::on_pong &quot; &lt;&lt; request_id &lt;&lt; &quot;, success: &quot; &lt;&lt; success &lt;&lt; &quot;\n&quot;;
        so_deregister_agent_coop_normally();
    }

    void on_timeout(mhood_t&lt;timeout_signal&gt; msg) {
        std::cout &lt;&lt; &quot;pinger::on_timeout\n&quot;;
        auto request_id = msg-&gt;request_id;
        request_map.erase(request_id);
        wrapped_pong cmd{request_id, request_error_t::TIMEOUT};
        on_pong_delivery(cmd);
    }

  public:
    pinger(context_t ctx) : so_5::agent_t{std::move(ctx)} {}

    void set_ponger(const so_5::mbox_t mbox) { ponger_ = mbox; }

    void so_define_agent() override { so_subscribe_self().event(&amp;pinger::on_pong).event(&amp;pinger::on_timeout); }

    void so_evt_start() override {
        auto request_id = ++last_request;
        so_5::send&lt;wrapped_ping&gt;(ponger_, request_id);
        auto timer = so_5::send_periodic&lt;timeout_signal&gt;(*this, so_direct_mbox(), 200ms,
                                                         std::chrono::milliseconds::zero(), request_id);
        auto timer_ptr = std::make_unique&lt;so_5::timer_id_t&gt;(std::move(timer));
        request_map.emplace(request_id, std::move(timer_ptr));
    }
};

class ponger final : public so_5::agent_t {
    const so_5::mbox_t pinger_;
    std::random_device rd;
    std::mt19937 gen;
    std::uniform_real_distribution&lt;&gt; distr;

  public:
    ponger(context_t ctx, so_5::mbox_t pinger) : so_5::agent_t{std::move(ctx)}, pinger_{std::move(pinger)}, gen(rd()) {}

    void so_define_agent() override {
        so_subscribe_self().event([this](mhood_t&lt;wrapped_ping&gt; msg) {
            auto dice_roll = distr(gen);
            std::cout &lt;&lt; &quot;ponger::on_ping &quot; &lt;&lt; msg-&gt;request_id &lt;&lt; &quot;, &quot; &lt;&lt; dice_roll &lt;&lt; &quot;\n&quot;;
            if (dice_roll &gt; 0.5) {
                std::cout &lt;&lt; &quot;ponger::on_ping (sending pong back)&quot; &lt;&lt; std::endl;
                so_5::send&lt;wrapped_pong&gt;(pinger_, msg-&gt;request_id, request_error_t::SUCCESS, pong{});
            }
        });
    }
};

int main() {
    so_5::launch([](so_5::environment_t &amp;env) {
        env.introduce_coop([](so_5::coop_t &amp;coop) {
            auto pinger_actor = coop.make_agent&lt;pinger&gt;();
            auto ponger_actor = coop.make_agent&lt;ponger&gt;(pinger_actor-&gt;so_direct_mbox());

            pinger_actor-&gt;set_ponger(ponger_actor-&gt;so_direct_mbox());
        });
    });

    return 0;
}
</code></pre>

<p>Output sample:</p>

<pre><code>ponger::on_ping 1, 0.475312
pinger::on_timeout
pinger::on_pong 1, success: 0
</code></pre>

<p>Other output sample:</p>

<pre><code>ponger::on_ping 1, 0.815891
ponger::on_ping (sending pong back)
pinger::on_pong 1, success: 1
</code></pre>

<p>It should be noted, that request/response pattern <em>was</em> supported in sobjectizer
<a href="https://sourceforge.net/p/sobjectizer/wiki/so-5.5%20In-depth%20-%20Synchronous%20Interaction/">before</a>
version <code>5.6</code>, however it was dropped (well, moved to
<a href="https://sourceforge.net/p/sobjectizer/wiki/About%20so5extra/]">sobjectizer-extra</a>, which has
different licensing terms). The request/response was easy as the following like:</p>

<pre><code>auto r = so_5::request_value&lt;Result,Request&gt;(mbox, timeout, params);
</code></pre>

<p>It is convenient; nevertheless, from the explanation sample &quot;How does it work?&quot;, the following
sample is available:</p>

<pre><code>// Waiting and handling the result.
auto wait_result__ = f__.wait_for(timeout);
if(std::future_status::ready != wait_result__)
   throw exception_t(...);
auto r = f__.get();
</code></pre>

<p>it suffers the same <strong>non-reactivity taint</strong> as described above, i.e. lack of possibility to
answer other messages, while waiting a response. Hence, you can see &quot;Deadlocks&quot; section
in the documentation, and the developers responsibility to handle the situation.</p>

<h1>req/res approach with CAF</h1>

<p>The <a href="http://actor-framework.org/">C++ actor framework</a> (aka CAF), does support request/response
approach.</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;string&gt;

#include &quot;caf/all.hpp&quot;
#include &quot;caf/optional.hpp&quot;
#include &quot;caf/sec.hpp&quot;

using std::endl;
using std::string;
using namespace std::literals;

using namespace caf;

using ping_atom = atom_constant&lt;atom(&quot;ping&quot;)&gt;;
using pong_atom = atom_constant&lt;atom(&quot;pong&quot;)&gt;;

void ping(event_based_actor *self, actor pong_actor) {
  aout(self) &lt;&lt; &quot;ping&quot; &lt;&lt; endl;

  self-&gt;request(pong_actor, 1s, ping_atom::value)
      .then([=](pong_atom ok) { aout(self) &lt;&lt; &quot;pong received&quot; &lt;&lt; endl; },
            [=](error err) {
              aout(self) &lt;&lt; &quot;pong was NOT received (timed out?), error code = &quot;
                         &lt;&lt; err.code() &lt;&lt; endl;
            });
}

behavior pong(event_based_actor *self) {
  using generator_t = std::shared_ptr&lt;std::mt19937&gt;;
  using distrbution_t = std::shared_ptr&lt;std::uniform_real_distribution&lt;double&gt;&gt;;

  std::random_device rd;
  auto gen = std::make_shared&lt;typename generator_t::element_type&gt;(rd());
  auto distr = std::make_shared&lt;typename distrbution_t::element_type&gt;();
  return {[=](ping_atom) {
    auto dice = (*distr)(*gen);
    aout(self) &lt;&lt; &quot;pong, dice = &quot; &lt;&lt; dice &lt;&lt; endl;
    if (dice &gt; 0.5) {
      return optional&lt;pong_atom&gt;(pong_atom::value);
    }
    return optional&lt;pong_atom&gt;();
  }};
}

void caf_main(actor_system &amp;system) {
  auto pong_actor = system.spawn(pong);
  auto ping_actor = system.spawn(ping, pong_actor);
}

CAF_MAIN()
</code></pre>

<p>Output sample:</p>

<pre><code>ping
pong, dice = 0.571207
pong received
</code></pre>

<p>Another output sample:</p>

<pre><code>ping
pong, dice = 0.270214
pong was NOT received (timed out?), error code = 2
</code></pre>

<p>The call <code>client_actor-&gt;request(server_actor, timeout, args..)</code> returns an intermediate
future-like object, where <code>then</code> method can be invoked with forwarded one-shot
actor behaviour. And, yes, there is <code>await</code> method too with non-reactive behaviour,
where you can shoot easily yourself with deadlock. So, according to the
<a href="https://actor-framework.readthedocs.io/en/latest/MessagePassing.html#sending-requests-and-handling-responses">documentation</a>
<code>then</code> method is what we need, as it &quot;multiplexes the one-shot handler with the
regular actor behaviour and handles requests as they arrive&quot;.</p>

<h1>req/res approach with rotor</h1>

<p>The <a href="https://github.com/basiliscos/cpp-rotor">rotor</a> does support request/response
approach since <code>v0.04</code></p>

<pre><code>#include &lt;rotor/ev.hpp&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;

namespace payload {
struct pong_t {};
struct ping_t {
    using response_t = pong_t;
};
} // namespace payload

namespace message {
using ping_t = rotor::request_traits_t&lt;payload::ping_t&gt;::request::message_t;
using pong_t = rotor::request_traits_t&lt;payload::ping_t&gt;::response::message_t;
} // namespace message

struct pinger_t : public rotor::actor_base_t {

    using rotor::actor_base_t::actor_base_t;

    void set_ponger_addr(const rotor::address_ptr_t &amp;addr) { ponger_addr = addr; }

    void on_initialize(rotor::message::init_request_t &amp;msg) noexcept override {
        rotor::actor_base_t::on_initialize(msg);
        subscribe(&amp;pinger_t::on_pong);
    }

    void on_start(rotor::message_t&lt;rotor::payload::start_actor_t&gt; &amp;) noexcept override {
        request&lt;payload::ping_t&gt;(ponger_addr).send(rotor::pt::seconds(1));
    }

    void on_pong(message::pong_t &amp;msg) noexcept {
        auto &amp;ec = msg.payload.ec;
        if (!msg.payload.ec) {
            std::cout &lt;&lt; &quot;pong received\n&quot;;
        } else {
            std::cout &lt;&lt; &quot;pong was NOT received: &quot; &lt;&lt; ec.message() &lt;&lt; &quot;\n&quot;;
        }
        supervisor.do_shutdown();
    }

    rotor::address_ptr_t ponger_addr;
};

struct ponger_t : public rotor::actor_base_t {
    using generator_t = std::mt19937;
    using distrbution_t = std::uniform_real_distribution&lt;double&gt;;

    std::random_device rd;
    generator_t gen;
    distrbution_t dist;

    ponger_t(rotor::supervisor_t &amp;sup) : rotor::actor_base_t{sup}, gen(rd()) {}

    void on_initialize(rotor::message::init_request_t &amp;msg) noexcept override {
        rotor::actor_base_t::on_initialize(msg);
        subscribe(&amp;ponger_t::on_ping);
    }

    void on_ping(message::ping_t &amp;req) noexcept {
        auto dice = dist(gen);
        std::cout &lt;&lt; &quot;pong, dice = &quot; &lt;&lt; dice &lt;&lt; std::endl;
        if (dice &gt; 0.5) {
            reply_to(req);
        }
    }
};

int main() {
    try {
        auto *loop = ev_loop_new(0);
        auto system_context = rotor::ev::system_context_ev_t::ptr_t{new rotor::ev::system_context_ev_t()};
        auto timeout = boost::posix_time::milliseconds{10};
        auto conf = rotor::ev::supervisor_config_ev_t{
            timeout, loop, true, /* let supervisor takes ownership on the loop */
        };
        auto sup = system_context-&gt;create_supervisor&lt;rotor::ev::supervisor_ev_t&gt;(conf);

        auto pinger = sup-&gt;create_actor&lt;pinger_t&gt;(timeout);
        auto ponger = sup-&gt;create_actor&lt;ponger_t&gt;(timeout);
        pinger-&gt;set_ponger_addr(ponger-&gt;get_address());

        sup-&gt;start();
        ev_run(loop);
    } catch (const std::exception &amp;ex) {
        std::cout &lt;&lt; &quot;exception : &quot; &lt;&lt; ex.what();
    }

    std::cout &lt;&lt; &quot;exiting...\n&quot;;
    return 0;
}
</code></pre>

<p>Output sample:</p>

<pre><code>pong, dice = 0.90477
pong received
</code></pre>

<p>Another output sample:</p>

<pre><code>pong, dice = 0.24427
pong was NOT received: request timeout
</code></pre>

<p>Comparing to <a href="http://actor-framework.org/">CAF</a>, <code>rotor</code>&#39;s version is more
verbose in the terms of LOC (lines of code). Partly this is caused by omitted
<code>main</code> in <code>CAF</code>, while in <code>rotor</code> the main cannot be shortened because
it is assumed to work with different loop backends as well as in cooperation
with them and other non-actor loop components; partly because of in <code>CAF</code>
the message is hidden from user, while in <code>rotor</code> is is exposed outside
due to performance reasons (i.e. allow the payload to be smart-pointer
to have zero-copy); and finally because of <code>CAFs</code> intensive usage of
lambdas, which leads to more compact code.</p>

<p>However, it is still what it needed: reactive reactive request-response.</p>

<h1>Request/Response composability</h1>

<p>On the top of <code>request-response</code> pattern, the <strong>ask pattern</strong> can be developed.
In short, an client-actor makes several of requests, and then, depending on the
results it makes an appropriate action. See
<a href="https://doc.akka.io/docs/akka/current/actors.html#ask-send-and-receive-future">akka</a>
docs as an example,</p>

<p>However, the <strong>ask pattern</strong> it is a little bit more general: it should be
possible to access to the initial context (message) as well as to all responses
(some of which might fail).</p>

<p>The <code>sobjectizer</code> does not offer support request-response patters, so it is out of
comparison. The <code>sobjectizer-extra</code> offers <code>std::future</code> based solution,
however, as we seen, it not reactive (<code>while(!fututure.is_ready()){ ... }</code>)
and as the <code>std::futures</code> are not compose-able, the <strong>ask pattern</strong> cannot
be implemented.</p>

<p>As we&#39;ve seen with <code>CAF</code> lambda approach, there are 2 lambdas <em>per request</em>
(one is for fail response and another is for success response); each one
captures outer request context and has access to its own response. Nonetheless,
none of the lambdas has access to the contexts of the other requests; in
other words the common context (which can include the original message)
should be <em>shared</em> between them, and the code compactness seems to lost.</p>

<p>Here is an example how to compose two ping-pong requests, where any of them
might fail.</p>

<pre><code>#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;string&gt;

#include &quot;caf/all.hpp&quot;
#include &quot;caf/optional.hpp&quot;
#include &quot;caf/sec.hpp&quot;

using std::endl;
using std::string;
using namespace std::literals;

using namespace caf;

using ping_atom = atom_constant&lt;atom(&quot;ping&quot;)&gt;;
using pong_atom = atom_constant&lt;atom(&quot;pong&quot;)&gt;;

struct shared_context_t {
  std::size_t pings_left;
  std::size_t pings_success = 0;
  std::size_t pings_error = 0;

  shared_context_t(std::size_t pings_left_) : pings_left{pings_left_} {}

  void output_results() {
    if (pings_left == 0) {
      // unsafe, aout should be used, but how to capture it?
      std::cout &lt;&lt; &quot;success: &quot; &lt;&lt; pings_success &lt;&lt; &quot;, errors: &quot; &lt;&lt; pings_error
                &lt;&lt; &quot;\n&quot;;
    }
  }
  void record_success() {
    ++pings_success;
    --pings_left;
    output_results();
  }
  void record_fail() {
    ++pings_error;
    --pings_left;
    output_results();
  }
};

void ping(event_based_actor *self, actor pong_actor1, actor pong_actor2) {
  aout(self) &lt;&lt; &quot;ping&quot; &lt;&lt; endl;

  auto context = std::make_shared&lt;shared_context_t&gt;(2);
  self-&gt;request(pong_actor1, 1s, ping_atom::value)
      .then([=](pong_atom ok) { context-&gt;record_success(); },
            [=](error err) { context-&gt;record_fail(); });
  self-&gt;request(pong_actor2, 1s, ping_atom::value)
      .then([=](pong_atom ok) { context-&gt;record_success(); },
            [=](error err) { context-&gt;record_fail(); });
}

behavior pong(event_based_actor *self) {
  using generator_t = std::shared_ptr&lt;std::mt19937&gt;;
  using distrbution_t = std::shared_ptr&lt;std::uniform_real_distribution&lt;double&gt;&gt;;

  std::random_device rd;
  auto gen = std::make_shared&lt;typename generator_t::element_type&gt;(rd());
  auto distr = std::make_shared&lt;typename distrbution_t::element_type&gt;();
  return {[=](ping_atom) {
    auto dice = (*distr)(*gen);
    aout(self) &lt;&lt; &quot;pong, dice = &quot; &lt;&lt; dice &lt;&lt; endl;
    if (dice &gt; 0.5) {
      return optional&lt;pong_atom&gt;(pong_atom::value);
    }
    return optional&lt;pong_atom&gt;();
  }};
}

void caf_main(actor_system &amp;system) {
  auto pong_actor1 = system.spawn(pong);
  auto pong_actor2 = system.spawn(pong);
  auto ping_actor = system.spawn(ping, pong_actor1, pong_actor2);
}

CAF_MAIN()
</code></pre>

<p>Output sample:</p>

<pre><code>ping
pong, dice = 0.818207
pong, dice = 0.140753
success: 1, errors: 1
</code></pre>

<p>Another output sample:</p>

<pre><code>ping
pong, dice = 0.832334
pong, dice = 0.744168
success: 2, errors: 0
</code></pre>

<p>I&#39;m not <code>CAF</code>s expert, but it seems that in shared context it needs to
be captured the original behaviour to access <code>aout</code>, and there is need
to have two methods per each request type (or single composed one
with takes composite monad-like result).</p>

<p>Let&#39;s see how it works with <code>rotor</code>, however actors&#39; addressing should be
explained first. <code>Akka</code> and <code>CAF</code> actor frameworks use the <code>ActorRef</code>
notion to (globally) identify an actor. It seems that there is one-to-one
matching between <code>ActorRef</code> and the actor. In <code>rotor</code> address is completely
decoupled from actor, and it can process messages on any address it is
subscribed to. There is &quot;main&quot; (or default) actors address which is used
for main <code>rotor</code> mechanics, still it can be subscribed to any address
and process messages on it.</p>

<p>That technique is shown below, when an <strong>ephemeral address</strong> is created
and an unique association between that address and context is created.
Here is a full code:</p>

<pre><code>#include &lt;rotor/ev.hpp&gt;
#include &lt;iostream&gt;
#include &lt;random&gt;
#include &lt;unordered_map&gt;

namespace payload {
struct pong_t {};
struct ping_t {
    using response_t = pong_t;
};
} // namespace payload

namespace message {
using ping_t = rotor::request_traits_t&lt;payload::ping_t&gt;::request::message_t;
using pong_t = rotor::request_traits_t&lt;payload::ping_t&gt;::response::message_t;
} // namespace message

struct shared_context_t {
    std::size_t pings_left;
    std::size_t pings_success = 0;
    std::size_t pings_error = 0;
};

struct pinger_t : public rotor::actor_base_t {
    using map_t = std::unordered_map&lt;rotor::address_ptr_t, shared_context_t&gt;;

    using rotor::actor_base_t::actor_base_t;

    void set_ponger_addr1(const rotor::address_ptr_t &amp;addr) { ponger_addr1 = addr; }
    void set_ponger_addr2(const rotor::address_ptr_t &amp;addr) { ponger_addr2 = addr; }

    void on_start(rotor::message_t&lt;rotor::payload::start_actor_t&gt; &amp;) noexcept override {
        reply_addr = create_address();
        subscribe(&amp;pinger_t::on_pong, reply_addr);
        request_via&lt;payload::ping_t&gt;(ponger_addr1, reply_addr).send(rotor::pt::seconds(1));
        request_via&lt;payload::ping_t&gt;(ponger_addr2, reply_addr).send(rotor::pt::seconds(1));
        request_map.emplace(reply_addr, shared_context_t{2});
    }

    void on_pong(message::pong_t &amp;msg) noexcept {
        auto &amp;ctx = request_map[msg.address];
        --ctx.pings_left;
        auto &amp;ec = msg.payload.ec;
        if (ec) {
            ++ctx.pings_error;
        } else {
            ++ctx.pings_success;
        }
        if (!ctx.pings_left) {
            std::cout &lt;&lt; &quot;success: &quot; &lt;&lt; ctx.pings_success &lt;&lt; &quot;, errors: &quot; &lt;&lt; ctx.pings_error &lt;&lt; &quot;\n&quot;;
            // optional cleanup
            unsubscribe(&amp;pinger_t::on_pong, reply_addr);
            request_map.erase(msg.address);
            supervisor.do_shutdown();
        }
    }

    map_t request_map;
    rotor::address_ptr_t ponger_addr1;
    rotor::address_ptr_t ponger_addr2;
    rotor::address_ptr_t reply_addr;
};

struct ponger_t : public rotor::actor_base_t {
    using generator_t = std::mt19937;
    using distrbution_t = std::uniform_real_distribution&lt;double&gt;;

    std::random_device rd;
    generator_t gen;
    distrbution_t dist;

    ponger_t(rotor::supervisor_t &amp;sup) : rotor::actor_base_t{sup}, gen(rd()) {}

    void on_initialize(rotor::message::init_request_t &amp;msg) noexcept override {
        rotor::actor_base_t::on_initialize(msg);
        subscribe(&amp;ponger_t::on_ping);
    }

    void on_ping(message::ping_t &amp;req) noexcept {
        auto dice = dist(gen);
        std::cout &lt;&lt; &quot;pong, dice = &quot; &lt;&lt; dice &lt;&lt; std::endl;
        if (dice &gt; 0.5) {
            reply_to(req);
        }
    }
};

int main() {
    try {
        auto *loop = ev_loop_new(0);
        auto system_context = rotor::ev::system_context_ev_t::ptr_t{new rotor::ev::system_context_ev_t()};
        auto timeout = boost::posix_time::milliseconds{10};
        auto conf = rotor::ev::supervisor_config_ev_t{
            timeout, loop, true, /* let supervisor takes ownership on the loop */
        };
        auto sup = system_context-&gt;create_supervisor&lt;rotor::ev::supervisor_ev_t&gt;(conf);

        auto pinger = sup-&gt;create_actor&lt;pinger_t&gt;(timeout);
        auto ponger1 = sup-&gt;create_actor&lt;ponger_t&gt;(timeout);
        auto ponger2 = sup-&gt;create_actor&lt;ponger_t&gt;(timeout);
        pinger-&gt;set_ponger_addr1(ponger1-&gt;get_address());
        pinger-&gt;set_ponger_addr2(ponger2-&gt;get_address());

        sup-&gt;start();
        ev_run(loop);
    } catch (const std::exception &amp;ex) {
        std::cout &lt;&lt; &quot;exception : &quot; &lt;&lt; ex.what();
    }

    std::cout &lt;&lt; &quot;exiting...\n&quot;;
    return 0;
}
</code></pre>

<p>Output sample:</p>

<pre><code>pong, dice = 0.472509
pong, dice = 0.305997
success: 0, errors: 2
</code></pre>

<p>Another output sample:</p>

<pre><code>pong, dice = 0.103796
pong, dice = 0.8862
success: 1, errors: 1
</code></pre>

<p>Rotor has special support of requests to be replied to custom addresses
(i.e. <code>request_via</code> method). The main difference with the <code>CAF</code> that instead
of multiple lambdas with additional methods (<code>record_success</code> and <code>record_fail</code>)
and &quot;gather-them-all&quot; method (<code>output_results</code>), with <code>rotor</code> there is
just single gather-them-all method (<code>on_pong</code>), which actually has exactly
the same signature when as the previous example with <code>rotor</code>.</p>

<h1>Conclusion</h1>

<p>When you start thinking about possible failures the initially request
response schema abruptly becomes non-trivial. Timeout and other errors
should be handled and without framework support the code quite quickly
becomes cumbersome.</p>

<p>There is still additional requirements, that the provided by a framework
support of request/response pattern did not come of cost of loosing
actor&#39;s <em>reactivity</em>; for simplicity, you may treat it as
dead-lock avoidance. Another nice-to-have feature would be composability
of the requests.</p>

<p>At the moment <code>sobjectizer</code> does not provides request/response pattern,
however in the past it did, however it was <em>non-reactive</em>.</p>

<p>Both <code>CAF</code> and <code>rotor</code> do provide request/response pattern keeping
still actors <em>reactive</em>. <code>CAF</code> has more compact code; the <code>rotor&#39;s</code>
code is more verbose. It seems that in <code>CAF</code> you should roll
you own composability of requests, i.e. develop context class
and make it shared between different requests handlers. In <code>rotor</code>
the composability of requests seems more natural via creating
ephemeral reply addresses, which can associate the linked group
of requests in single place.</p>

<h1>Update</h1>

<p>The <code>sobjectizer</code> author replied with separate
<a href="https://eao197.blogspot.com/2019/10/progc-follow-up-for-basiliscoss-article.html">article</a>.
, which I recommend to read.</p>

<p>So, it should be updated, that <a href="https://github.com/Stiffstream/so5extra">sobjetizer-extra</a>
provides support for request-response pattern, but only via a bit
different name (<code>async_op</code>, in the case). It is completely
asynchronous and free of dead-locks, i.e. <strong>reactive</strong>.</p>

<p>It is also
<a href="https://github.com/eao197/so5-request-reply-example/blob/master/dev/sample_composability_2/main.cpp">composable</a>,
with the approximately same lines of code as <code>rotor</code> example.
The composability is done via lambdas (as in <code>CAF</code>), but
the responses are redirected to different <code>mboxes</code> (as the
ephemeral addresses in <code>rotor</code>).</p>

<p>So, it is possible to get the same result with all considered
frameworks.</p>



</article>

<ul class="pager">
    <li class="prev">
            <a class="button button-primary" href="/blog/page/2/" rel="prev">
                â† Older
            </a>
    </li>
    <li class="next">
            <button disabled>
                Newer â†’
            </button>
    </li>
</ul>




                    </main>
                </div>

                <div class="three columns sidebar">
                    
                        <nav id="tags">
        <h1>Tags</h1>
        <ul class="list-inline">
            <li><a href="/blog/tag/c/">c++</a></li>
            <li><a href="/blog/tag/rotor/">rotor</a></li>
        </ul>
    </nav>

                            <h1>Feeds</h1>
        <ul class="list-inline">
            <li>
                <a href="/blog/index.atom" rel="alternate" type="application/atom+xml">
                    Atom
                </a>
            </li>
            <li>
                <a href="/blog/index.rss" rel="alternate" type="application/rss+xml">
                    RSS
                </a>
            </li>
        </ul>

                </div>
            </div>
        </div>
        <footer>
            
            <div class="container tagline">
                <a href="http://preaction.me/statocles">Made with Statocles</a><br>
                <a href="http://www.perl.org">Powered by Perl</a>
            </div>
        </footer>


    </body>
</html>
